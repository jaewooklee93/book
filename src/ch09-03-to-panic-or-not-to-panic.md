## `panic!`을 사용할지 말지

`panic!`을 호출할 때와 `Result`를 반환할 때를 결정하는 방법은 무엇일까요?
코드가 panic하면 복구할 방법이 없습니다. `panic!`를 모든 오류 상황에 대해 호출할 수 있지만, 그렇게 하면 호출 코드가 상황이 복구 불가능하다는 결정을 대신하게 됩니다. `Result` 값을 반환하면 호출 코드가 선택할 수 있는 옵션을 제공합니다. 호출 코드는 상황에 맞게 복구하려고 시도하거나, 이 경우 `Err` 값이 복구 불가능하다고 결정하여 `panic!`를 호출하고, 복구 가능한 오류를 복구 불가능한 오류로 바꿀 수 있습니다. 따라서 함수가 실패할 수 있는 경우 `Result`를 반환하는 것이 좋은 기본 선택입니다.

예제, 프로토타입 코드, 테스트와 같은 상황에서는 `Result`를 반환하는 대신 `panic!`를 사용하여 코드를 작성하는 것이 더 적절합니다. 왜 그런지 살펴보고, 컴파일러가 실패가 불가능하다고 알 수 없는 경우, 하지만 당신은 인간으로서 알 수 있는 경우에 대해 논의할 것입니다. 이 장은 라이브러리 코드에서 `panic!`을 사용할지 여부를 결정하는 일반적인 지침으로 마무리됩니다.

### 예제, 프로토타입 코드, 및 테스트

어떤 개념을 설명하는 예제를 작성할 때, 견고한 오류 처리 코드를 포함하면 예제가 덜 명확해질 수 있습니다. 예제에서는 `unwrap`과 같은 메서드 호출이 `panic!`을 일으킬 수 있다는 것을 이해합니다. 이는 응용 프로그램이 오류를 처리하는 방식이 다를 수 있기 때문에, 예제에서 오류를 처리하는 방식을 나타내는 것으로 간주됩니다.

마찬가지로, `unwrap`와 `expect` 메서드는 `Result`를 반환하는 대신 `panic!`을 사용하여 코드를 작성하는 것이 더 적절합니다. 이들은 코드에서 오류 처리를 강화할 준비가 되었을 때 명확한 마커를 남깁니다.

테스트에서 메서드 호출이 실패하면 테스트 전체가 실패해야 합니다. `panic!`가 테스트를 실패로 표시하는 방식이기 때문에 `unwrap` 또는 `expect`를 호출하는 것이 정확히 해야 할 일입니다.

### 컴파일러가 알 수 없는 경우

`Result`가 `Ok` 값을 가질 것이라는 것을 보장하는 다른 논리적 구조가 있다면 `unwrap` 또는 `expect`를 호출하는 것도 적절합니다. 하지만 이 논리는 컴파일러가 이해하지 못하는 것입니다. 여전히 처리해야 할 `Result` 값이 있지만, 특정 상황에서는 논리적으로 `Err` 값이 불가능하지만, 일반적으로는 `parse` 메서드의 반환 유형이 여전히 `Result`이며, 컴파일러는 `Err` 값이 가능성이 있는 것처럼 `Result`를 처리하도록 강요합니다. 만약 코드를 수동으로 검토하여 `Err` 값이 없을 것이라고 확신할 수 있다면 `unwrap`를 호출하는 것이 완벽하며, `expect` 텍스트에 `Err` 값이 없을 것이라고 생각하는 이유를 설명하는 것이 좋습니다. 예를 들어 보겠습니다.

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

`127.0.0.1`이 유효한 IP 주소이기 때문에 `expect`를 사용하는 것이 허용됩니다. 하지만, 고정된 문자열이라는 사실은 `parse` 메서드의 반환 유형을 바꾸지 않습니다. 여전히 `Result` 값을 얻으며, 컴파일러는 이 문자열이 항상 유효한 IP 주소라는 것을 알 수 없기 때문에 `Result`를 `Err` 값이 가능성이 있는 것처럼 처리하도록 강요합니다. IP 주소 문자열이 사용자로부터 입력된 경우, 즉 `panic!`을 호출하는 대신 `Result`를 더 견고하게 처리해야 할 때입니다. 고정된 IP 주소라는 가정을 언급하면, 미래에 IP 주소를 다른 출처에서 가져오는 경우 `expect`를 더 나은 오류 처리 코드로 변경해야 할 필요성이 생길 것입니다.

### 오류 처리 지침

코드가 좋지 않은 상태로 끝날 수 있는 경우, 즉 어떤 가정, 보장, 계약 또는 불변이 위반된 경우 `panic!`을 사용하는 것이 좋습니다. 예를 들어, 유효하지 않은 값, 모순된 값 또는 누락된 값이 코드에 전달되는 경우입니다.다음과 같은 경우에 더 많이 사용할 수 있습니다.

* 문제 상태는 예상치 못한 것이며, 사용자가 잘못된 형식으로 데이터를 입력하는 것과 같이 가끔 발생할 가능성이 있는 것은 아닙니다.
* 이후 코드는 이러한 나쁜 상태를 의존하지 않고, 모든 단계에서 문제를 확인하는 대신 이를 기반으로 해야 합니다.
* 이러한 정보를 사용하는 유형에 효과적으로 표현할 방법이 없습니다. 17장의 “유형으로 상태와 동작을 표현하기”[encoding]<!-- ignore --> 섹션에서 어떤 의미인지 살펴보겠습니다.

누군가 코드를 호출하고 의미가 없는 값을 전달하면 라이브러리 사용자가 어떻게 대처할지 결정할 수 있도록 오류를 반환하는 것이 가장 좋습니다. 그러나 계속 진행하면 안전하거나 해로운 경우에는 `panic!`를 호출하여 라이브러리 사용자에게 코드의 버그를 알리고 개발 중에 수정하도록 하는 것이 좋습니다. 마찬가지로, 제어할 수 없는 외부 코드를 호출하고 유효하지 않은 상태를 반환하는 경우 `panic!`가 적절합니다. 

그러나 실패가 예상되는 경우에는 `Result`를 반환하는 것이 `panic!`를 호출하는 것보다 적절합니다. 예를 들어, 파서가 잘못된 데이터를 받거나 HTTP 요청이 속도 제한을 넘어섰다는 상태 코드를 반환하는 경우입니다. 이러한 경우 `Result`를 반환하면 실패가 예상 가능한 가능성이며 호출 코드가 어떻게 처리할지 결정해야 합니다.

코드가 유효하지 않은 값을 사용하면 사용자에게 위험을 초래할 수 있는 경우, 코드는 먼저 값이 유효한지 확인하고 유효하지 않으면 `panic!`을 호출해야 합니다. 이는 안전상의 이유 때문입니다. 유효하지 않은 데이터를 처리하려는 시도는 코드가 취약점에 노출될 수 있습니다. 표준 라이브러리가 현재 데이터 구조에 속하지 않는 메모리에 액세스하려는 시도를 하면 `panic!`를 호출하는 이유입니다. 함수는 종종 *계약*을 가지고 있습니다. 입력이 특정 요구 사항을 충족하면 동작이 보장됩니다. 계약 위반 시 `panic!`을 호출하는 것은 합리적입니다. 왜냐하면 계약 위반은 항상 호출자 측 버그를 나타내기 때문이며, 호출 코드가 명시적으로 처리해야 하는 종류의 오류가 아닙니다. 실제로 호출 코드가 복구할 수 있는 방법은 없습니다. 호출하는 *프로그래머*가 코드를 수정해야 합니다. 특히 위반 시 `panic!`를 호출하는 함수의 계약은 함수의 API 문서에 설명되어야 합니다.

그러나 모든 함수에 오류 확인을 많이 추가하면 번거롭고 귀찮습니다. 다행히 Rust의 유형 시스템(즉, 컴파일러가 수행하는 유형 검사)을 사용하여 많은 검사를 대신할 수 있습니다. 함수에 특정 유형이 매개변수로 전달된 경우, 컴파일러가 이미 유효한 값이라는 것을 보장했기 때문에 코드의 논리로 진행할 수 있습니다. 예를 들어, `Option`이 아닌 유형이 있다면 프로그램은 *무언가*를 기대하며 *아무것도*가 아닌 것을 기대하지 않습니다. 따라서 코드는 `Some`과 `None` 변형에 대한 두 가지 경우를 처리할 필요가 없습니다. 유효하지 않은 값을 함수에 전달하려는 코드는 컴파일되지 않으므로 함수는 런타임에 해당 경우를 처리할 필요가 없습니다. 또 다른 예는 `u32`와 같은 무符号 정수 유형을 사용하는 것입니다. 이는 매개변수가 항상 음수가 아니라는 것을 보장합니다.

### 사용자 검증을 위한 사용자 정의 유형 만들기

Rust의 유형 시스템을 사용하여 유효한 값을 가지고 있는지 확인하는 것을 한 단계 더 발전시켜 사용자 정의 유형을 만들어 보겠습니다. 2장의 추리 게임에서 코드가 사용자의 추측이 1에서 100 사이인지 확인하지 않았습니다. 우리는 추측이 긍정적이라는 것을 확인했지만, 추측이 범위 내에 있는지 확인하지 않았습니다. 이 경우 결과가 매우 심각하지는 않았습니다. 우리의 “너무 높다” 또는 “너무 낮다” 출력은 여전히 ​​올바르게 작동했습니다. 그러나 사용자를 유효한 추측으로 안내하고 사용자가 문자를 입력하는 경우와 같은 범위 밖의 추측을 입력했을 때 다른 동작을 수행하는 것은 유용한 향상이 될 것입니다.

이를 수행하는 한 가지 방법은 `i32`로 추측을 파싱하는 것입니다. 잠재적으로 음수를 허용하고 범위 내인지 확인하는 추가 검사를 추가하는 것입니다.

## panic!을 사용하거나 사용하지 않을까?

Filename: src/main.rs

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

`if` 표현식은 우리의 값이 범위 밖인지 확인하고, 사용자에게 문제에 대해 알리고, `continue`를 호출하여 루프의 다음 반복을 시작하고 다른 추측을 요청합니다. `if` 표현식 이후에는 `guess`가 1에서 100 사이에 있음을 알고 있기 때문에 `guess`와 비밀 숫자 간의 비교를 진행할 수 있습니다.

그러나 이것은 이상적인 해결책이 아닙니다. 프로그램이 1에서 100 사이의 값만 사용해야 한다는 것이 매우 중요하고, 이러한 요구 사항을 가진 많은 함수가 있다면, 모든 함수에서 이러한 확인을 수행하는 것은 번거롭습니다 (성능에 영향을 미칠 수도 있습니다).

대신, 새로운 유형을 만들고 유효성 검사를 함수에 넣어 유형의 인스턴스를 생성하여 모든 곳에서 유효성 검사를 반복하지 않도록 할 수 있습니다. 이렇게 하면 함수가 서명에서 새로운 유형을 사용하고 받는 값을 확신할 수 있습니다.

9-13번 목록은 `Guess` 유형을 정의하는 한 가지 방법을 보여줍니다. `Guess::new` 함수가 받은 값이 1에서 100 사이인지 확인하여 `Guess` 인스턴스를 생성합니다.

Filename: src/lib.rs

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-13/src/lib.rs}}
```

Listing 9-13: 1에서 100 사이의 값만 허용하는 `Guess` 유형

먼저 `value`라는 필드를 가진 `Guess`라는 구조체를 정의합니다. 이 필드는 숫자를 저장할 것입니다.

그런 다음 `Guess`에 `new`이라는 연관 함수를 구현합니다. 이 함수는 `Guess` 값을 생성합니다. `new` 함수는 `value`라는 이름의 `i32` 유형의 하나의 매개변수를 가지고 `Guess`를 반환합니다. `new` 함수의 코드는 `value`를 테스트하여 1에서 100 사이인지 확인합니다. 만약 `value`가 이 테스트를 통과하지 못하면 `panic!` 함수를 호출합니다. 이는 호출 코드를 작성하는 프로그래머에게 버그가 있음을 알리고 해결해야 함을 알립니다. `Guess::new`가 의존하는 계약을 위반하기 때문입니다. `Guess::new`이 `panic!`을 호출할 수 있는 조건은 14장에서 다룰 예시 문서화에서 설명되어야 합니다.
 만약 `value`가 테스트를 통과하면 `value` 필드가 `value` 매개변수로 설정된 새로운 `Guess`를 생성하고 반환합니다.

다음으로 `value`라는 이름의 메서드를 구현합니다. 이 메서드는 `self`를 대여하고 다른 매개변수를 가지지 않으며 `i32`를 반환합니다. 이러한 종류의 메서드는 *getter*라고도 불립니다. 이 메서드의 목적은 데이터를 가져와 반환하는 것입니다. 이러한 공개 메서드는 `Guess` 구조체의 `value` 필드가 private이기 때문에 필요합니다. `Guess` 구조체를 사용하는 코드가 `value` 필드를 직접 설정할 수 없도록 `value` 필드를 private로 하는 것이 중요합니다. 모듈 외부의 코드는 `Guess` 인스턴스를 생성하기 위해 `Guess::new` 함수를 사용해야 하며, 이를 통해 `Guess`가 `Guess::new` 함수에서 검사되지 않은 `value`를 가지는 경우를 방지할 수 있습니다.

1에서 100 사이의 숫자만 매개변수 또는 반환하는 함수는 서명에서 `Guess`를 `i32` 대신 사용하여 선언할 수 있으며, 함수 본문에서 추가적인 검사가 필요하지 않습니다.

## 요약

Rust의 오류 처리 기능은 더욱 견고한 코드를 작성하는 데 도움이 되도록 설계되었습니다. `panic!` 매크로는 프로그램이 처리할 수 없는 상태에 있음을 나타내고 프로세스를 중지하도록 알려줍니다. `Result` enum은 Rust의 타입 시스템을 사용하여 작업이 실패할 수 있지만 코드가 복구할 수 있는 방식을 나타냅니다.코드를 호출하는 코드에 잠재적인 성공 또는 실패를 처리해야 한다는 것을 알리는 데 `Result`를 사용합니다. `panic!`과 `Result`를 적절한 상황에서 사용하면 필수적인 문제에 직면했을 때 코드가 더욱 안정적으로 작동합니다.

이제 `Option`과 `Result` enum과 함께 제네릭을 사용하는 표준 라이브러리의 유용한 방법을 보았으므로, 제네릭이 어떻게 작동하고 코드에서 어떻게 사용하는지에 대해 알아보겠습니다.

[encoding]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
