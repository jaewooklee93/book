<!-- Old heading. Do not remove or links may break. -->
<a id=\"closures-anonymous-functions-that-can-capture-their-environment\"></a>

## Closures: 익명 함수가 자신의 환경을 포착하는 것

Rust의 Closures는 변수에 저장하거나 다른 함수의 인수로 전달할 수 있는 익명 함수입니다. 한 곳에서 closure를 만들고 다른 맥락에서 호출하여 평가할 수 있습니다. 함수와 달리, closures는 정의된 범위의 값을 포착할 수 있습니다. 이러한 closure 기능을 통해 코드 재사용 및 동작 사용자 정의를 보여드리겠습니다.

<!-- Old headings. Do not remove or links may break. -->
<a id=\"creating-an-abstraction-of-behavior-with-closures\"></a>
<a id=\"refactoring-using-functions\"></a>
<a id=\"refactoring-with-closures-to-store-code\"></a>

### Closures로 환경을 포착하는 방법

먼저, Closures를 사용하여 정의된 범위의 값을 포착하여 나중에 사용하는 방법을 살펴보겠습니다. 다음은 우리의 상황입니다: 우리의 티셔츠 회사는 정기적으로 이메일 목록에 있는 사람들에게 한정판 티셔츠를 선물합니다. 이메일 목록에 있는 사람들은 자신의 좋아하는 색상을 프로필에 추가할 수 있습니다. 무료 티셔츠를 받는 사람이 좋아하는 색상을 설정했다면 해당 색상의 티셔츠를 받습니다. 좋아하는 색상을 지정하지 않은 사람은 회사가 현재 가장 많이 가지고 있는 색상의 티셔츠를 받습니다.

이를 구현하는 방법은 여러 가지가 있습니다. 이 예제에서는 `ShirtColor`라는 `enum`을 사용하여 `Red`와 `Blue`의 변형을 가지고 있습니다(단순성을 위해 색상의 수를 제한합니다). 회사의 재고를 나타내는 `Inventory` 구조체는 `shirts`라는 필드를 가지고 있으며, 현재 재고에 있는 티셔츠 색상을 나타내는 `Vec<ShirtColor>`를 포함합니다. `Inventory`에 정의된 `giveaway` 메서드는 무료 티셔츠 당첨자의 옵셔널 티셔츠 색상 선호도를 가져오고 사람이 받을 티셔츠 색상을 반환합니다. 이 설정은 Listing 13-1에 나와 있습니다:

<Listing number=\"13-1\" file-name=\"src/main.rs\" caption=\"티셔츠 회사의 선물 상황\">

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

</Listing>

`main`에서 정의된 `store`에는 두 개의 파란색 티셔츠와 하나의 빨간색 티셔츠가 남아 있습니다. 이 제한판 프로모션을 위해 배포해야 합니다. `giveaway` 메서드를 빨간색 티셔츠를 선호하는 사용자와 선호도가 없는 사용자에게 호출합니다.

다시 한번, 이 코드는 여러 가지 방법으로 구현할 수 있으며, 여기서는 이미 배운 개념에 붙잡히기 위해 `giveaway` 메서드의 몸체를 제외하고는 `closures`에 초점을 맞추었습니다. `giveaway` 메서드에서 `user_preference`라는 매개변수로 사용자 선호도를 가져오고 `unwrap_or_else` 메서드를 호출합니다. `Option<T>`의 `unwrap_or_else` 메서드는 표준 라이브러리에서 정의되어 있습니다. `Some` 변형에 있는 값을 반환하는 `unwrap_or_else` 메서드는 `Some` 변형에 있는 값을 반환합니다. `Option<T>`가 `None` 변형이라면 `unwrap_or_else`는 closure를 호출하고 closure에서 반환된 값을 반환합니다.

`|| self.most_stocked()`를 `unwrap_or_else`의 인수로 지정합니다. 이것은 매개변수를 받지 않는 closure입니다(closure에 매개변수가 있다면 두 개의 수직 바 사이에 표시됩니다). closure의 몸체는 `self.most_stocked()`를 호출합니다. closure를 여기서 정의하고, `unwrap_or_else`의 구현은 필요한 경우 closure를 평가합니다.

이 코드를 실행하면 다음과 같이 출력됩니다:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

여기에서 흥미로운 점은 현재 `Inventory` 인스턴스에서 `self.most_stocked()`를 호출하는 closure를 전달했기 때문입니다. 표준 라이브러리
필요하지 않았습니다. `Inventory` 또는 `ShirtColor`와 같은 유형에 대해 알아야 하거나, 이 시나리오에서 사용하려는 논리에 대해 알아야 할 필요가 없습니다. 폐쇄는 `self` `Inventory` 인스턴스에 대한 불변 참조를 캡처하고 `unwrap_or_else` 메서드에 지정된 코드와 함께 전달합니다. 반면 함수는 이런 방식으로 환경을 캡처할 수 없습니다.

### 폐쇄 유형 추론 및 주석

함수와 폐쇄 사이에는 더 많은 차이점이 있습니다. 폐쇄는 일반적으로 `fn` 함수와 같이 매개변수 또는 반환 값의 유형을 주석으로 지정할 필요가 없습니다. 유형 주석은 함수에 필요합니다. 왜냐하면 유형은 사용자에게 노출되는 명시적인 인터페이스의 일부이기 때문입니다. 이러한 인터페이스를 엄격하게 정의하는 것은 함수가 어떤 유형의 값을 사용하고 반환하는지에 대한 일관된 이해를 보장하는 데 중요합니다. 반면 폐쇄는 이러한 노출된 인터페이스에서 사용되지 않습니다. 폐쇄는 변수에 저장되어 있으며 라이브러리 사용자에게 명명하거나 노출하지 않고 사용됩니다.

폐쇄는 일반적으로 특정 맥락 내에서만 유효하며, 임의의 시나리오에서는 유효하지 않습니다. 이러한 제한된 맥락에서 컴파일러는 매개변수와 반환 유형의 유형을 추론할 수 있습니다. 컴파일러가 대부분의 변수의 유형을 추론할 수 있는 방식과 유사합니다. (컴파일러가 폐쇄 유형 주석도 필요한 드문 경우가 있습니다.)

변수와 마찬가지로 유형을 명시적으로 지정하여 명확성을 높이고, 컴파일러가 유형을 추론하는 데 필요한 정보를 제공할 수 있습니다. 폐쇄에 유형 주석을 추가하면 Listing 13-2와 같이 함수 정의와 유사한 문법이 됩니다. 이 예에서는 폐쇄를 정의하고 변수에 저장하고 있습니다. Listing 13-1과 같이 폐쇄를 전달하는 인자로 정의하는 대신입니다.

<Listing number=\"13-2\" file-name=\"src/main.rs\" caption=\"폐쇄 매개변수 및 반환 값 유형의 선택적 유형 주석 추가\">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

</Listing>

유형 주석이 추가되면 폐쇄 문법이 함수 문법과 더 유사해집니다. `add_one_v1` 함수 정의와 동일한 동작을 하는 폐쇄를 정의했습니다. 몇 가지 공간을 추가하여 관련 부분을 정렬했습니다. 이는 폐쇄 문법이 함수 문법과 유사하지만 파이프와 필요한 문법의 양이 선택적이라는 것을 보여줍니다.

```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

첫 번째 줄은 함수 정의를 보여주고 두 번째 줄은 완전히 주석이 있는 폐쇄 정의를 보여줍니다. 세 번째 줄에서는 폐쇄 정의에서 유형 주석을 제거했습니다. 네 번째 줄에서는 폐쇄 코드가 하나의 표현식만 있기 때문에 괄호를 제거했습니다. 이러한 모든 것은 호출될 때 동일한 동작을 생성하는 유효한 정의입니다. `add_one_v3` 및 `add_one_v4` 줄은 컴파일러가 유형을 추론할 수 있도록 폐쇄를 평가해야만 컴파일이 가능합니다. 이는 `let v = Vec::new();`와 유사합니다. 컴파일러가 유형을 추론하기 위해 `Vec`에 유형 주석이나 어떤 유형의 값을 삽입해야 합니다.

폐쇄 정의의 경우 컴파일러는 매개변수와 반환 값에 대해 하나의 구체적인 유형을 추론합니다. 예를 들어 Listing 13-3은 매개변수로 받은 값을 반환하는 간단한 폐쇄의 정의를 보여줍니다. 이 폐쇄는 이 예제의 목적 외에는 별로 유용하지 않습니다. 유형 주석을 추가하지 않았습니다. 유형 주석이 없기 때문에 폐쇄를 `String`과 같은 어떤 유형으로 호출할 수 있습니다. 처음에는 `String`으로 폐쇄를 호출했습니다. 그런 다음 정수로 `example_closure`를 호출하려고 하면 오류가 발생합니다.

<Listing number=\"13-3\" file-name=\"src/main.rs\" caption=\"컴파일러가 추론한 유형을 가진 폐쇄를 두 가지 다른 유형으로 호출하려고 시도\">

```rust,ignore,does_not_compile
## 13.01 익명 함수 (Closures)

익명 함수는 코드 블록을 정의하는 데 사용되는 Rust의 강력한 기능입니다. 익명 함수는 이름이 없는 함수로, 필요할 때 필요한 작업을 수행하는 데 유용합니다. 익명 함수는 다른 함수의 인수로 전달하거나, 변수에 할당하거나, 다른 익명 함수에 전달할 수 있습니다.

### 익명 함수의 예시

다음은 익명 함수를 사용하는 간단한 예시입니다. 이 예시에서는 익명 함수를 사용하여 두 정수를 더하는 작업을 수행합니다.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

이 코드는 다음과 같은 출력을 생성합니다.

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

### 익명 함수의 타입

익명 함수는 타입이 있습니다. 익명 함수의 타입은 인수의 타입과 반환 값의 타입을 나타냅니다. 예를 들어, 위의 예시에서 익명 함수의 타입은 `fn(i32, i32) -> i32`입니다.

익명 함수의 타입은 컴파일러가 익명 함수를 사용하는 방법을 이해하도록 돕습니다. 익명 함수의 타입을 명시적으로 지정할 수도 있습니다.

### 익명 함수의 캡처

익명 함수는 주변 환경에서 값을 캡처할 수 있습니다. 이러한 값은 익명 함수가 실행될 때 사용될 수 있습니다. 익명 함수는 값을 캡처하는 세 가지 방법을 사용합니다.

* **불변 참조 캡처:** 익명 함수는 주변 환경에서 값의 불변 참조를 캡처할 수 있습니다. 이는 익명 함수가 값을 변경하지 않을 때 사용됩니다.
* **변경 가능 참조 캡처:** 익명 함수는 주변 환경에서 값의 변경 가능 참조를 캡처할 수 있습니다. 이는 익명 함수가 값을 변경할 때 사용됩니다.
* **소유권 캡처:** 익명 함수는 주변 환경에서 값의 소유권을 캡처할 수 있습니다. 이는 익명 함수가 값을 소유하고 변경할 때 사용됩니다.

### 예시

다음은 익명 함수가 값을 캡처하는 방법을 보여주는 예시입니다.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs}}
```

이 코드는 다음과 같은 출력을 생성합니다.

```console
{{#include ../listings
listings/ch13-functional-features/listing-13-02/output.txt}}
```

### 주의 사항

익명 함수를 사용할 때 주의해야 할 사항은 다음과 같습니다.

* 익명 함수는 주변 환경에서 값을 캡처할 수 있으므로, 익명 함수가 사용하는 값이 변경되지 않도록 주의해야 합니다.
* 익명 함수는 주변 환경에서 값의 소유권을 캡처할 수 있으므로, 익명 함수가 소유한 값이 변경되거나 소멸되지 않도록 주의해야 합니다.

익명 함수는 Rust에서 매우 유용한 기능입니다. 익명 함수를 사용하면 코드를 더 간결하고 재사용 가능하게 만들 수 있습니다.
클로저 몸체가 목록을 출력합니다. 13-4번 목록에서 클로저는 `list`를 불변 참조를 사용하여만 캡처했습니다. 왜냐하면 `list`를 인쇄하기 위해 필요한 접근 권한이 가장 적기 때문입니다. 이 예제에서는 클로저 몸체가 여전히 불변 참조만 필요하더라도, `list`가 클로저로 옮겨져야 한다는 것을 명시해야 합니다. `move` 키워드를 클로저 정의의 시작 부분에 넣습니다. 새로운 스레드가 메인 스레드보다 먼저 완료되거나, 메인 스레드가 먼저 완료될 수 있습니다. 메인 스레드가 `list`의 소유권을 유지하면서 새로운 스레드가 완료되기 전에 종료하고 `list`를 삭제하면 스레드의 불변 참조가 무효가 됩니다. 따라서 컴파일러는 참조가 유효하도록 새로운 스레드에 전달되는 클로저에 `list`를 옮겨야 한다고 요구합니다. `move` 키워드를 제거하거나 클로저가 정의된 후 메인 스레드에서 `list`를 사용해보세요. 컴파일러 오류가 무엇인지 확인하세요!

<!-- Old headings. Do not remove or links may break. -->
<a id=\"storing-closures-using-generic-parameters-and-the-fn-traits\"></a>
<a id=\"limitations-of-the-cacher-implementation\"></a>
<a id=\"moving-captured-values-out-of-the-closure-and-the-fn-traits\"></a>

### 클로저에서 캡처된 값을 옮기고 `Fn` 트레이트

클로저가 정의된 환경에서 참조를 캡처하거나 값의 소유권을 캡처하면(즉, 클로저에 *옮겨지는* 것에 영향을 미치면), 클로저의 몸체 코드는 클로저가 나중에 평가될 때 참조 또는 값에 대해 어떻게 처리하는지 정의합니다(즉, 클로저에서 *옮겨지는* 것에 영향을 미칩니다). 클로저 몸체는 다음 중 하나를 수행할 수 있습니다. 캡처된 값을 클로저에서 옮기거나, 캡처된 값을 변형하거나, 값을 옮기거나 변형하지 않거나, 처음부터 환경에서 아무것도 캡처하지 않습니다.

클로저가 환경에서 값을 캡처하고 처리하는 방식은 클로저가 구현하는 트레이트에 영향을 미칩니다. 트레이트는 함수와 구조체가 어떤 종류의 클로저를 사용할 수 있는지 지정하는 방식입니다. 클로저는 몸체가 값을 처리하는 방식에 따라 자동으로 다음 중 하나 또는 세 가지 `Fn` 트레이트를 구현합니다.

1. `FnOnce`는 한 번만 호출할 수 있는 클로저에 적용됩니다. 모든 클로저는 적어도 이 트레이트를 구현합니다. 왜냐하면 모든 클로저는 호출될 수 있기 때문입니다. 클로저 몸체에서 캡처된 값을 옮기면 `FnOnce`만 구현하고 다른 `Fn` 트레이트는 구현하지 않습니다. 왜냐하면 한 번만 호출할 수 있기 때문입니다.
2. `FnMut`는 클로저 몸체에서 캡처된 값을 옮기지 않지만, 캡처된 값을 변형할 수 있는 클로저에 적용됩니다. 이러한 클로저는 여러 번 호출할 수 있습니다.
3. `Fn`은 클로저 몸체에서 캡처된 값을 옮기지 않고 캡처된 값을 변형하지 않으며, 환경에서 아무것도 캡처하지 않는 클로저에도 적용됩니다. 이러한 클로저는 환경을 변형하지 않고 여러 번 동시에 호출할 수 있습니다. 이는 `Option<T>`의 `unwrap_or_else` 메서드의 정의를 살펴보면서 이해할 수 있습니다.

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

`T`는 `Option`의 `Some` 변형에서 값의 유형을 나타내는 일반적인 유형입니다. `unwrap_or_else` 함수의 반환 유형도 `T`입니다. `unwrap_or_else`를 `Option<String>`에 호출하는 코드는 `String`을 가져옵니다.

다음으로, `unwrap_or_else` 함수는 추가적인 일반적인 유형 매개변수 `F`를 가지고 있습니다. `F` 유형은 `f`라는 매개변수의 유형입니다. `f`는 `unwrap_or_else`를 호출할 때 제공하는 클로저입니다.

`F` 유형에 지정된 트레이트 경계는 `FnOnce() -> T`입니다. 즉, `F`는 한 번만 호출할 수 있어야 하며, 인수를 받지 않고 `T`를 반환해야 합니다. `FnOnce`를 트레이트 경계에 사용하는 것은 `f`가 한 번만 호출될 수 있다는 제약을 나타냅니다.
 `unwrap_or_else`는 `f`를 최대 한 번만 호출할 것입니다. `unwrap_or_else`의 몸체에서 볼 수 있듯이, `Option`이 `Some`이면 `f`는 호출되지 않으며, `Option`이 `None`이면 `f`는 한 번 호출됩니다. 모든 클로저가 `FnOnce`를 구현하기 때문에 `unwrap_or_else`는 모든 세 가지 유형의 클로저를 받아들이며 최대한 유연합니다.

>참고: 함수는 `Fn` 트레이트의 세 가지를 모두 구현할 수 있습니다. 환경에서 값을 캡처하지 않아야 하는 경우, 정렬할 때 `Fn` 트레이트 중 하나를 구현하는 것을 필요로 하는 경우 함수 이름 대신 클로저를 사용할 수 있습니다. 예를 들어, `Option<Vec<T>>` 값에 대해 `unwrap_or_else(Vec::new)`를 호출하면 값이 `None`이면 새롭고 비어있는 벡터를 얻을 수 있습니다.

이제 슬라이스에 정의된 표준 라이브러리 메서드 `sort_by_key`를 살펴보고 `unwrap_or_else`와 어떻게 다르며 `sort_by_key`가 `FnMut`를 `FnOnce` 대신 트레이트 경계로 사용하는 이유를 살펴보겠습니다. 클로저는 슬라이스에서 고려 중인 현재 항목에 대한 참조 형태로 하나의 인수를 받고, 정렬할 수 있는 `K` 유형의 값을 반환합니다. 이 함수는 각 항목의 특정 속성에 따라 슬라이스를 정렬하고 싶을 때 유용합니다. 13-7번 목록에서는 `Rectangle` 인스턴스의 목록이 있고 `sort_by_key`를 사용하여 `width` 속성에 따라 낮은 값부터 높은 값까지 정렬합니다.

<Listing number="13-7" file-name="src/main.rs" caption="`sort_by_key`를 사용하여 직사각형의 너비로 정렬">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
```

</Listing>

이 코드는 다음과 같이 출력됩니다.

```console
{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
```

`sort_by_key`가 `FnMut` 클로저를 가져오는 이유는 슬라이스의 각 항목에 대해 한 번씩 클로저를 호출하기 때문입니다. `|r| r.width` 클로저는 환경에서 값을 캡처하거나 변경하거나 이동하지 않으므로 트레이트 경계 요구 사항을 충족합니다.

반면에 13-8번 목록은 `FnOnce` 트레이트만 구현하는 클로저의 예를 보여줍니다. 클로저는 환경에서 값을 이동하기 때문입니다. 컴파일러는 `sort_by_key`와 클로저를 사용하지 못하게 합니다.

<Listing number="13-8" file-name="src/main.rs" caption="`sort_by_key`에 `FnOnce` 클로저를 사용하려는 시도">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}
```

</Listing>

이것은 `sort_by_key`가 클로저를 호출할 때마다 몇 번 호출되는지 세는 데 사용되는, (작동하지 않는) 모순된 복잡한 방법입니다. 이 코드는 `sort_by_key`가 클로저를 호출할 때마다 `value`를 `sort_operations` 벡터에 푸시하여 클로저를 호출하는 횟수를 세려고 합니다. 클로저는 `value`를 캡처한 다음 `value`를 `sort_operations` 벡터로 이동하여 소유권을 전달합니다. 이 클로저는 한 번만 호출할 수 있습니다. 두 번째로 호출하려면 `value`가 `sort_operations`에 다시 푸시될 수 없기 때문입니다. 따라서 이 클로저는 `FnOnce`만 구현합니다. 클로저의 몸체에서 `value`를 환경에서 이동하려고 하는 부분을 보면 컴파일러는 `value`를 클로저에서 옮길 수 없다고 말합니다. 이 클로저는 `FnMut`를 구현해야 합니다.

`FnMut`를 구현해야 하는 이유는 `sort_by_key`가 클로저를 여러 번 호출하기 때문입니다. 각 호출에서 클로저는 `value`를 변경할 수 있습니다. `FnOnce`는 클로저를 한 번만 호출할 수 있도록 합니다.


클로저 몸체는 그 계산을 더 직관적인 방법으로 수행합니다. 13-9번 목록의 클로저는 `sort_by_key`와 작동하기 때문입니다. `num_sort_operations` 카운터에 대한 변경 가능한 참조만 캡처하기 때문입니다. 따라서 여러 번 호출할 수 있습니다.

<Listing number=\"13-9\" file-name=\"src/main.rs\" caption=\"`FnMut` 클로저를 사용하여 `sort_by_key`는 허용됩니다\">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
```

</Listing>

`Fn` 트레이트는 클로저를 사용하는 함수 또는 유형을 정의하거나 사용할 때 중요합니다. 다음 섹션에서는 이터레이터에 대해 논의할 것입니다. 많은 이터레이터 메서드가 클로저 인수를 받기 때문에, 계속 진행하면서 이 클로저 세부 사항을 염두에 두세요!

[unwrap-or-else]: ../std/option/enum.Option.html#method.unwrap_or_else
