## `Rc<T>`, 참조 카운트 스마트 포인터

대부분의 경우, 소유권은 명확합니다. 어떤 변수가 특정 값을 소유하고 있는지 정확히 알 수 있습니다. 그러나 한 값이 여러 소유자를 가질 수 있는 경우도 있습니다. 예를 들어 그래프 데이터 구조에서 여러 간선이 같은 노드로 연결될 수 있으며, 그 노드는 연결하는 모든 간선에 의해 개념적으로 소유됩니다. 간선이 노드로 연결되지 않고 소유자가 없을 때까지 노드는 정리되어서는 안 됩니다.

Rust에서 여러 소유권을 명시적으로 허용하려면 `Rc<T>` 유형을 사용해야 합니다. `Rc<T>`는 값에 대한 참조 수를 추적하여 값이 여전히 사용 중인지 여부를 결정하는 *참조 카운팅*의 약자입니다. 값에 대한 참조가 0개일 경우, 참조가 무효화되는 것 없이 값을 정리할 수 있습니다.

`Rc<T>`를 TV에 비유해 보세요. 가족 방에 TV가 있을 때, 한 사람이 TV를 보려고 들어오면 TV를 켭니다. 다른 사람들이 방에 들어와 TV를 볼 수 있습니다. 마지막 사람이 방을 나갈 때, TV를 끄기 때문에 더 이상 사용되지 않기 때문입니다.
만약 누군가 TV를 끄는 동안 다른 사람들이 여전히 TV를 보고 있다면, 남은 TV 시청자들에게는 큰 문제가 생깁니다!

`Rc<T>` 유형은 여러 프로그램 부분이 읽을 수 있도록 힙에 데이터를 할당할 때 사용합니다. 컴파일 시간에 어떤 부분이 데이터를 마지막으로 사용하는지 알 수 없을 때입니다. 어떤 부분이 마지막으로 사용하는지 알 수 있다면, 그 부분을 데이터의 소유자로 만들고 컴파일 시간에 강제되는 정상 소유권 규칙이 적용됩니다.

`Rc<T>`는 단일 스레드 시나리오에서만 사용하는 것입니다. 제16장에서 병렬 처리를 다룰 때, 여러 스레드에서 참조 카운팅을 수행하는 방법을 살펴보겠습니다.

### `Rc<T>`를 사용하여 데이터 공유

15-5번 목록에서 본 연결 리스트 예제로 돌아가겠습니다. `Box<T>`를 사용하여 정의한 것으로 기억하십시오. 이번에는 두 개의 리스트가 세 번째 리스트의 소유권을 공유하는 경우를 만들겠습니다. 개념적으로 이것은 15-3번 그림과 유사합니다.

<img alt=\"두 개의 리스트가 세 번째 리스트의 소유권을 공유하는 경우\" src=\"img/trpl15-03.svg\" class=\"center\" />

그림 15-3: 두 개의 리스트 `b`와 `c`가 첫 번째 리스트 `a`의 소유권을 공유하는 경우

`a`라는 리스트를 5와 10을 포함하도록 만들고, `b`는 3으로 시작하고 `c`는 4로 시작하는 두 개의 리스트를 만들겠습니다. `b`와 `c` 두 개의 리스트는 모두 5와 10을 포함하는 첫 번째 리스트를 계속해서 사용합니다. 즉, 두 개의 리스트는 모두 5와 10을 포함하는 첫 번째 리스트를 공유합니다.

`Box<T>`를 사용하여 `List`를 정의했을 때, 이러한 시나리오를 구현하려고 하면 15-17번 목록에서 보는 것처럼 작동하지 않습니다.

Filename: src/main.rs

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

15-17번 목록: `Box<T>`를 사용하여 두 개의 리스트가 세 번째 리스트의 소유권을 공유하려고 하는 것을 시도하는 것을 보여줍니다

이 코드를 컴파일하면 다음과 같은 오류 메시지가 표시됩니다.

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

`Cons` 변형체는 자신이 가진 데이터를 소유하기 때문에 `b` 리스트를 만들 때 `a`가 `b`로 이동되고 `b`가 `a`를 소유하게 됩니다. 그런 다음 `c`를 만들 때 `a`를 다시 사용하려고 하면 `a`가 이미 이동되었기 때문에 사용할 수 없습니다.

`Cons`를 참조를 저장하도록 변경할 수 있지만, 그렇게 하면 라이프타임 매개변수를 지정해야 합니다. 라이프타임 매개변수를 지정하면 리스트의 모든 요소가 리스트 전체만큼 적어도 오래 살아남는다는 것을 의미합니다. 15-17번 목록의 요소와 리스트의 경우에는 이것이 사실이지만, 모든 경우에 그렇지는 않습니다.

대신 `Rc<T>`를 사용하여 `List`의 정의를 변경할 것입니다.
Listing 15-18에서 보여주는 것처럼 `Box<T>`를 사용합니다. 각 `Cons` 변형체는 이제 값과 `Rc<T>`를 가리키는 포인터를 갖습니다. `List`를 생성합니다. `b`를 생성할 때, `a`의 소유권을 가져오는 대신 `a`가 가진 `Rc<List>`를 복사하여 참조 개수를 1에서 2로 늘리고 `a`와 `b`가 `Rc<List>` 내부 데이터를 공유하도록 합니다. `c`를 생성할 때 `a`를 복사하여 참조 개수를 2에서 3으로 늘립니다. `Rc::clone`을 호출할 때마다 `Rc<List>` 내부 데이터에 대한 참조 개수가 증가하며, 참조가 없는 경우에만 데이터가 정리됩니다.

Filename: src/main.rs

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

Listing 15-18: `Rc<T>`를 사용하는 `List` 정의

`main`에서 리스트를 생성하고 5와 10을 저장하여 `Rc<List>`에 저장합니다. `b`와 `c`를 생성할 때 `Rc::clone` 함수를 호출하여 `a`의 `Rc<List>`를 인자로 전달합니다.

`a.clone()`을 호출하는 것도 가능하지만, Rust의 관습은 이 경우 `Rc::clone`을 사용하는 것입니다. `Rc::clone`은 대부분의 타입의 `clone` 구현과 달리 모든 데이터의 깊은 복사를 수행하지 않습니다. `Rc::clone` 호출은 참조 개수만 증가시킵니다. 깊은 복사는 많은 시간이 걸릴 수 있습니다. `Rc::clone`을 사용하여 참조 개수를 세기 때문에 깊은 복사 유형의 복사와 참조 개수를 증가시키는 유형의 복사를 시각적으로 구분할 수 있습니다. 성능 문제를 찾을 때 코드에서 깊은 복사 복사만 고려하고 `Rc::clone` 호출은 무시할 수 있습니다.

### `Rc<T>`를 복사하면 참조 개수가 증가합니다

Listing 15-18의 예제를 변경하여 `Rc<List>`에 대한 참조 개수가 `a`, `b`, `c`가 생성되고 소멸될 때마다 어떻게 변하는지 확인할 수 있습니다.

Listing 15-19에서 `main` 함수 내부에 리스트 `c`를 감싸는 내부 범위를 추가하여 `c`가 범위를 벗어날 때 참조 개수 변화를 볼 수 있습니다.

Filename: src/main.rs

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

Listing 15-19: 참조 개수 출력

참조 개수가 변경되는 각 지점에서 `Rc::strong_count` 함수를 호출하여 참조 개수를 출력합니다. 이 함수는 `Rc<T>` 유형이 `weak_count`를 가지고 있기 때문에 `strong_count`로 명명됩니다. `weak_count`는 `Rc<T>`를 사용하는 방법에 대한 자세한 내용은 `[Rc<T>를 사용하여 참조 주기를 방지하기: `Rc<T>`를 `Weak<T>`로 변환하기]`<!-- ignore --> 섹션에서 설명합니다.

이 코드는 다음과 같은 출력을 생성합니다.

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

`a`의 `Rc<List>`의 초기 참조 개수는 1입니다. `clone`을 호출할 때마다 개수가 1씩 증가합니다. `c`가 범위를 벗어날 때 개수가 1씩 감소합니다. `Rc<T>` 값이 범위를 벗어날 때 참조 개수를 감소시키는 함수를 호출할 필요가 없습니다. `Drop` 트레이트의 구현이 자동으로 참조 개수를 감소시킵니다.

이 예제에서 볼 수 없는 것은 `b`와 `a`가 범위를 벗어날 때 참조 개수가 0이 되면 데이터가 정리되는 것입니다.


main 함수의 끝에서 카운트가 0이 되면 `Rc<List>`가 완전히 정리됩니다. `Rc<T>`를 사용하면 하나의 값이 여러 소유자를 가질 수 있으며, 카운트는 어떤 소유자가 여전히 존재하는지 확인하여 값이 유효한 동안 유지됩니다.

불변 참조를 통해 `Rc<T>`는 프로그램의 여러 부분에서 읽기 전용으로 데이터를 공유할 수 있도록 합니다. 만약 `Rc<T>`가 여러 변형 참조를 허용했다면, 4장에서 논의된 대로 대상에 대한 여러 변형 참조를 가져올 수 있으며, 이는 데이터 레이스 및 일관성 문제를 일으킬 수 있습니다. 하지만 데이터를 변형하는 능력은 매우 유용합니다! 다음 섹션에서는 내부 변형 패턴과 `Rc<T>`와 함께 사용하여 이러한 불변성 제한을 해결할 수 있는 `RefCell<T>` 유형에 대해 논의할 것입니다.

[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt