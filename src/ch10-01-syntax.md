## 제네릭 데이터 유형

제네릭을 사용하여 함수 서명이나 구조체와 같은 항목에 대한 정의를 만들고, 이를 여러 다른 구체 데이터 유형과 함께 사용할 수 있습니다. 먼저 함수, 구조체, 열거형 및 메서드를 정의하는 방법을 살펴보겠습니다. 그런 다음 제네릭이 코드 성능에 미치는 영향에 대해 논의하겠습니다.

### 함수 정의에서

제네릭을 사용하여 함수를 정의할 때, 함수 매개변수와 반환 값의 데이터 유형을 일반적으로 지정하는 위치에 제네릭을 넣습니다. 이렇게 하면 코드가 더 유연해지고 함수의 호출자에게 더 많은 기능을 제공하면서 코드 중복을 방지합니다.

`largest` 함수를 계속해서 살펴보겠습니다. 10-4번 목록은 두 개의 함수를 보여주는데, 두 함수 모두 슬라이스에서 가장 큰 값을 찾습니다. 이제 이들을 제네릭을 사용하는 하나의 함수로 통합해 보겠습니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

<span class=\"caption\">Listing 10-4: 이름과 서명의 유형만 다른 두 함수</span>

`largest_i32` 함수는 10-3번 목록에서 추출한 `i32` 슬라이스에서 가장 큰 값을 찾는 함수입니다. `largest_char` 함수는 슬라이스에서 가장 큰 `char` 값을 찾습니다. 함수 본문은 동일하므로 제네릭 데이터 유형을 사용하여 하나의 함수로 코드를 통합할 수 있습니다.

새로운 함수에 유형 매개변수를 파라미터화하려면 유형 매개변수 이름을 지정해야 합니다. 유형 매개변수 이름으로는 임의의 식별자를 사용할 수 있습니다. 하지만 `T`를 사용할 것입니다. 왜냐하면 Rust에서 유형 매개변수 이름은 일반적으로 짧고, 종종 한 글자만 사용되며, Rust의 유형 명명 규칙은 UpperCamelCase이기 때문입니다. `T`는 *유형*의 약자로, 대부분의 Rust 프로그래머가 선호하는 기본 선택입니다.

함수 본문에서 매개변수를 사용할 때는 컴파일러가 해당 이름이 무엇을 의미하는지 알 수 있도록 매개변수 이름을 서명에 선언해야 합니다. 유형 매개변수 이름을 함수 서명에서 사용할 때도 마찬가지입니다. 제네릭 유형을 정의하려면 함수 이름과 매개변수 목록 사이에 각각의 유형 이름을 선언하는 각각의 괄호 `<>` 안에 유형 이름을 넣습니다.

```rust,ignore
fn largest<T>(list: &[T]) -> &T {
```

이 정의를 읽으면 `largest` 함수는 어떤 유형 `T`에 대해 일반화된 함수임을 알 수 있습니다. 이 함수는 `T` 유형의 값으로 구성된 슬라이스 `list`라는 하나의 매개변수를 가지고 있습니다. `largest` 함수는 `T` 유형의 값에 대한 참조를 반환합니다.

10-5번 목록은 제네릭 데이터 유형을 사용하는 `largest` 함수 정의를 보여줍니다. 이 목록은 `i32` 값 또는 `char` 값의 슬라이스로 함수를 호출하는 방법을 보여줍니다. 이 코드는 아직 컴파일되지 않지만, 이 장에서 나중에 수정할 것입니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

<span class=\"caption\">Listing 10-5: 제네릭 유형 매개변수를 사용하는 `largest` 함수; 아직 컴파일되지 않음</span>

이 코드를 지금 바로 컴파일하면 다음과 같은 오류 메시지를 받습니다.

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

도움말 텍스트는 `std::cmp::PartialOrd`라는 *trait*를 언급하고 있으며, 다음 섹션에서 trait에 대해 논의할 것입니다. 지금은 이 오류 메시지가 `T`가 될 수 있는 모든 가능한 유형에 대해 `largest` 함수의 본문이 작동하지 않음을 나타낸다는 것을 알아두세요. 함수 본문에서 `T` 유형의 값을 비교하려면, 값을 비교할 수 있는 유형이어야 합니다. 표준 라이브러리는 `std::cmp::PartialOrd`라는 trait를 제공하여 비교를 가능하게 합니다(참고: Appendix C에서 이 trait에 대한 자세한 내용을 참조하세요). 도움말 텍스트의 지시에 따라 `PartialOrd` trait를 구현하면 코드가 컴파일될 것입니다.

제안 사항으로, `T`에 유효한 유형을 `PartialOrd`를 구현하는 유형으로 제한하면 이 예제가 컴파일됩니다. 표준 라이브러리는 `i32`와 `char` 모두에 `PartialOrd`를 구현하기 때문입니다.

### 구조 정의에서

또한 구조체를 정의하여 하나 이상의 필드에 일반적인 유형 매개변수를 사용할 수 있습니다. 10-6번 목록은 모든 유형의 `x` 및 `y` 좌표 값을 저장하는 `Point<T>` 구조체를 정의합니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

<span class=\"caption\">Listing 10-6: `Point<T>` 구조체는 유형 `T`의 `x` 및 `y` 값을 저장합니다</span>

구조체 정의에서 일반형을 사용하는 문법은 함수 정의에서 사용하는 문법과 유사합니다. 먼저 구조체 이름 뒤에 각각 괄호 안에 유형 매개변수의 이름을 선언합니다. 그런 다음 구조체 정의에서 구체적인 데이터 유형을 대신하여 일반적인 유형을 사용합니다.

`Point<T>`를 정의할 때 하나의 일반적인 유형만 사용했기 때문에, 이 정의는 `Point<T>` 구조체가 어떤 유형인지에 관계없이 `T`라는 일반적인 유형에 대해 일반적이라는 것을 의미합니다. `Point<T>`의 인스턴스를 생성할 때 `x`와 `y` 필드가 모두 같은 유형이어야 합니다. 10-7번 목록과 같이 다른 유형의 값을 가진 `Point<T>` 인스턴스를 생성하면 코드가 컴파일되지 않습니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

<span class=\"caption\">Listing 10-7: `x`와 `y` 필드는 같은 유형이어야 합니다. `x`와 `y`는 같은 일반 데이터 유형 `T`입니다.</span>

이 예제에서는 `x`에 정수 값 `5`를 할당할 때 컴파일러에게 `T`라는 일반 유형이 이 `Point<T>` 인스턴스에 대해 정수라는 것을 알립니다. 그런 다음 `y`에 `4.0`을 지정할 때, `x`와 같은 유형이어야 하므로 유형 불일치 오류가 발생합니다.

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

`x`가 유형 `T`이고 `y`가 유형 `U`인 `Point` 구조체를 정의하려면 10-8번 목록과 같이 `T`와 `U`라는 두 개의 일반 유형 매개변수를 사용하여 `Point`를 정의할 수 있습니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

<span class=\"caption\">Listing 10-8: `Point<T, U>`는 두 가지 유형에 대해 일반적이며 `x`와 `y`는 각각 다른 유형일 수 있습니다</span>

이제 모든 `Point` 인스턴스가 허용됩니다! `Point` 정의에 필요한 만큼 많은 일반 유형 매개변수를 사용할 수 있지만, 너무 많이 사용하면 코드가 읽기 어려워집니다. 코드에 많은 일반 유형 매개변수가 필요하다면 코드를 더 작은 부분으로 재구성해야 할 수 있습니다.

### 열거형 정의에서

구조체와 마찬가지로 열거형을 정의하여 변이 안에 일반적인 데이터 유형을 포함할 수 있습니다. 표준 라이브러리에서 제공하는 `Option<T>` 열거형을 다시 살펴보겠습니다. 이 열거형은 6장에서 사용했습니다.

```rust
enum Option<T> {
    Some(T),
    None,
}
```

이 정의가 이제 더 명확해졌을 것입니다. `Option<T>` 열거형은 유형 `T`에 대해 일반적이며 `Some` 변이 하나의 `T` 유형 값을 포함하고 `None` 변이는 값을 포함하지 않는다는 것을 알 수 있습니다.
 `Option<T>` enum을 사용하면 옵셔널 값의 추상 개념을 표현할 수 있으며, `Option<T>`가 제네릭이기 때문에 옵셔널 값의 유형에 관계없이 이 추상화를 사용할 수 있습니다.

제네릭을 사용하여 여러 유형을 사용할 수 있는 범위를 넓힐 수 있습니다. 9장에서 사용한 `Result` enum은 그 예입니다.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Result` enum은 `T`와 `E` 두 가지 유형에 대해 제네릭이며, `Ok`와 `Err` 두 가지 변형을 가지고 있습니다. `Ok`는 `T` 유형의 값을 담고 있으며, `Err`는 `E` 유형의 값을 담습니다. 이 정의는 성공할 수도 있고 실패할 수도 있는 작업에 `Result` enum을 사용하는 데 편리합니다. (어떤 유형의 `T`를 반환하거나 `E` 유형의 오류를 반환합니다.) 실제로 9-3번 목록에서 파일을 열 때 사용했는데, 파일이 성공적으로 열리면 `T`는 `std::fs::File` 유형으로 채워지고, 파일을 열 때 문제가 발생하면 `E`는 `std::io::Error` 유형으로 채워집니다.

코드에서 여러 구조체 또는 enum 정의가 값이 저장하는 유형만 다를 때, 중복을 피하기 위해 제네릭 유형을 사용할 수 있습니다.

### 메서드 정의에서

구조체와 enum에 메서드를 구현할 수 있으며 (5장에서 살펴봤듯이) 제네릭 유형을 메서드 정의에서도 사용할 수 있습니다. 10-9번 목록은 10-6번 목록에서 정의한 `Point<T>` 구조체에 `x`라는 이름의 메서드를 구현하는 것을 보여줍니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

<span class=\"caption\">Listing 10-9: `Point<T>` 구조체에 `x`라는 이름의 메서드를 구현하는 것. 이 메서드는 `x` 필드의 참조를 반환합니다.</span>

여기서 `Point<T>`에 `x`라는 이름의 메서드를 정의하여 `x` 필드의 데이터에 대한 참조를 반환합니다.

`impl` 뒤에 `T`를 선언해야 `T`를 사용하여 `Point<T>` 유형에 대해 메서드를 구현한다는 것을 알 수 있습니다. `T`를 제네릭 유형으로 선언함으로써 Rust는 각각의 구조체에서 `Point` 안의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각시그니처를 추가하여 예제를 더 명확하게 합니다. 이 메서드는 `self` `Point` (타입 `X1`)의 `x` 값과 전달된 `Point` (타입 `Y2`)의 `y` 값을 사용하여 새로운 `Point` 인스턴스를 생성합니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

<span class=\"caption\">Listing 10-11: 구조체 정의와 다른 일반형을 사용하는 메서드</span>

`main`에서 `Point`를 정의했는데, `x`는 `i32` (값은 `5`)이고, `y`는 `f64` (값은 `10.4`)입니다. `p2` 변수는 `x`에 문자열 슬라이스 (값은 `\"Hello\"`)와 `y`에 `char` (값은 `c`)를 가진 `Point` 구조체입니다. `p1`에 `p2`를 인자로 `mixup`를 호출하면 `p3`가 생성되며, `x`는 `p1`에서 가져오기 때문에 `i32`가 됩니다. `p3` 변수는 `y`를 `p2`에서 가져오기 때문에 `char`가 됩니다. `println!` 매크로 호출은 `p3.x = 5, p3.y = c`를 출력합니다.

이 예제의 목적은 `impl`을 사용하여 일부 일반형 매개변수를 선언하고, 메서드 정의에서 다른 일반형 매개변수를 선언하는 상황을 보여주는 것입니다. 여기서는 `X1`과 `Y1`은 구조체 정의와 함께 `impl` 뒤에 선언되고, `X2`와 `Y2`는 `fn mixup` 뒤에 선언됩니다. 이는 `X2`와 `Y2`가 메서드에만 관련이 있기 때문입니다.

### 일반형을 사용하는 코드의 성능

일반형 매개변수를 사용하면 런타임에 비용이 발생하는지 궁금해할 수 있습니다. 좋은 소식은 일반형을 사용해도 프로그램이 구체적인 형을 사용할 때보다 느리지 않다는 것입니다.

Rust는 컴파일 시간에 일반형 코드를 특정 코드로 변환하는 모노모르피즘을 수행하여 이를 달성합니다. *모노모르피즘*은 일반형 코드를 사용하는 모든 곳에서 특정 형을 채우고 변환하는 과정입니다. 컴파일러는 일반형 코드가 호출되는 모든 곳을 살펴보고 일반형 코드가 호출되는 특정 형에 대한 코드를 생성합니다.

표준 라이브러리의 일반형 `Option<T>` enum을 사용하여 이것을 살펴보겠습니다.

```rust
let integer = Some(5);
let float = Some(5.0);
```

Rust가 이 코드를 컴파일할 때 모노모르피즘을 수행합니다. 그 과정에서 컴파일러는 `Option<T>` 인스턴스에서 사용된 값을 읽고 `i32`과 `f64` 두 가지 종류의 `Option<T>`를 식별합니다. 따라서 `Option<T>`의 일반적인 정의를 `i32`과 `f64`에 특화된 두 가지 정의로 확장합니다. 즉, 일반적인 정의를 특정 정의로 대체합니다.

컴파일러가 사용하는 다른 이름으로 이 코드를 컴파일된 모습을 보여줍니다. (이 예시를 위해 우리가 사용하는 이름과는 다릅니다.)

<span class=\"filename\">Filename: src/main.rs</span>

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

일반형 `Option<T>`는 컴파일러가 생성한 특정 정의로 대체됩니다. Rust가 일반형 코드를 각 인스턴스에서 유형을 명시하는 코드로 컴파일하기 때문에 일반형을 사용하는 데 런타임 비용이 발생하지 않습니다. 코드가 실행될 때, 우리가 코드를 직접 복제했을 때와 동일하게 실행됩니다. 모노모르피즘 과정을 통해 Rust의 일반형은 런타임에서 매우 효율적입니다.
