## 라이프타임을 사용한 참조 유효성 검증

라이프타임은 이미 사용해왔던 또 다른 유형의 제네릭입니다. 유형이 원하는
동작을 보장하는 대신, 라이프타임은 참조가 필요한 만큼 유효하도록
보장합니다.

제4장의 \"참조 및 대여\"<!-- ignore --> 섹션에서 논하지 않았던
한 가지는 Rust에서 모든 참조에 *라이프타임*이 있는 것입니다. 라이프타임은
참조가 유효한 범위입니다. 대부분의 경우 라이프타임은 암묵적이며
인ferred됩니다. 유형이 인ferred되는 것처럼. 여러 유형이 가능할 때만
유형을 표시해야 합니다. 마찬가지로, 참조의 라이프타임이 여러 가지
방식으로 관련될 수 있을 때 라이프타임을 표시해야 합니다. Rust는
실행 시 사용되는 실제 참조가 반드시 유효하도록 보장하기 위해
일반적인 라이프타임 매개변수를 사용하여 관계를 표시하도록 요구합니다.

라이프타임을 표시하는 것은 대부분의 다른 프로그래밍 언어에서
보는 개념이 아니므로 익숙하지 않을 것입니다. 이 장에서는 라이프타임을
완전히 다루지 않지만, 라이프타임 구문을 어떻게 만나게 될지에 대한
일반적인 방법을 설명하므로 개념에 익숙해질 수 있습니다.

### 라이프타임을 사용하여 Dangling 참조 방지

라이프타임의 주요 목표는 *Dangling 참조*를 방지하는 것입니다. Dangling
참조는 프로그램이 의도하지 않은 데이터를 참조하는 원인이 됩니다.
10-16번 목록에서 보는 것처럼 외부 범위와 내부 범위가 있는 프로그램을
고려해 보겠습니다.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}
```

<span class=\"caption\">10-16번 목록: 값이 범위를 벗어난 참조를 사용하려는 시도</span>

> 참고: 10-16, 10-17, 10-23번 목록의 예제는 초기값이 없는 변수를 선언하므로
> 변수 이름이 외부 범위에 존재합니다. 처음에는 이것이 Rust의 null 값이
> 없는 것과 모순되는 것처럼 보일 수 있습니다. 그러나 변수에 값을
> 할당하기 전에 변수를 사용하려고 하면 컴파일 시 오류가 발생하며,
> Rust는 실제로 null 값을 허용하지 않는다는 것을 보여줍니다.

외부 범위는 `r`이라는 변수를 초기값 없이 선언하고, 내부 범위는 `x`라는
변수를 5로 초기화합니다. 내부 범위에서 `r`을 `x`의 참조로 설정하려고
합니다. 그런 다음 내부 범위가 끝나고 외부 범위에서 `r`의 값을 출력하려고
합니다. 이 코드는 `x`가 내부 범위가 끝날 때 범위를 벗어나기 때문에
컴파일되지 않습니다. 오류 메시지는 다음과 같습니다.

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}
```

오류 메시지는 `x`가 \"충분히 오래 살지 않음\"을 말합니다. 이유는 `x`가
내부 범위가 끝날 때 범위를 벗어나기 때문입니다. `r`은 외부 범위가 더
넓기 때문에, 우리는 그것이 \"더 오래 살아남음\"이라고 말합니다. Rust가
이 코드를 작동하게 허용하면 `r`은 `x`가 해제될 때 메모리를 참조하게
되고, `r`을 사용하려고 하면 무엇이든 올바르게 작동하지 않을 것입니다.
그래서 Rust는 이 코드가 무효임을 어떻게 파악할까요? 보로 체커를
사용합니다.

### 보로 체커

Rust 컴파일러에는 모든 보로가 유효한지 확인하기 위해 범위를 비교하는
*보로 체커*가 있습니다. 10-17번 목록은 10-16번 목록과 동일한 코드를
라이프타임 표시를 사용하여 표시한 것입니다.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}
```

<span class=\"caption\">10-17번 목록: `r`과 `x`의 라이프타임을 `'a`와 `'b`로 표시</span>

여기서 `r`의 라이프타임을 `'a`로, `x`의 라이프타임을 `'b`로 표시했습니다.
내부 `'b` 블록이 외부 `'a` 블록보다 훨씬 작다는 것을 알 수 있습니다.

 `'a` 라이프타임 블록입니다. 컴파일 시점에 Rust은 두 라이프타임의 크기를 비교하고 `r`이 `'a`라는 라이프타임을 가지고 있지만 `'b`라는 라이프타임을 가진 메모리에 참조한다는 것을 알아냅니다. 프로그램은 `'b`가 `'a`보다 짧기 때문에 거부됩니다. 즉, 참조의 대상이 참조만큼 오래 살지 않습니다.

10-18번 목록은 코드를 수정하여 Dangling Reference를 방지하고 오류 없이 컴파일되도록 합니다.

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}
```

<span class=\"caption\">10-18번 목록: 데이터가 참조보다 더 오래 유효하기 때문에 유효한 참조</span>

여기서 `x`는 `'b`라는 라이프타임을 가지고 있으며, 이 경우 `'a`보다 큽니다. 즉, `r`이 `x`를 참조할 수 있습니다. Rust는 `r`의 참조가 항상 유효할 때까지 `x`가 유효하다는 것을 알기 때문입니다.

이제 참조의 라이프타임이 무엇이며 Rust이 참조가 항상 유효하도록 라이프타임을 분석하는지 알고 있다면, 함수의 매개변수 및 반환값의 일반적인 라이프타임을 탐구해 보겠습니다.

### 함수의 일반적인 라이프타임

두 문자열 슬라이스의 더 긴 것을 반환하는 함수를 작성합니다. 이 함수는 두 문자열 슬라이스를 받아 하나의 문자열 슬라이스를 반환합니다. `longest` 함수를 구현한 후 10-19번 목록의 코드는 `The longest string is abcd`를 출력해야 합니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}
```

<span class=\"caption\">10-19번 목록: `longest` 함수를 호출하여 두 문자열 슬라이스 중 더 긴 것을 찾는 `main` 함수</span>

참고로 함수는 문자열 슬라이스를 받고 싶습니다. 문자열 슬라이스는 참조이기 때문입니다. `longest` 함수가 매개변수의 소유권을 가지지 않고 싶습니다. 4장의 "String Slices as Parameters" 섹션을 참조하여 10-19번 목록에서 사용하는 매개변수가 원하는 매개변수인 이유에 대한 자세한 내용을 확인하십시오.

10-20번 목록에 나와 있는 `longest` 함수를 구현하려고 하면 컴파일되지 않습니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}
```

<span class=\"caption\">10-20번 목록: 컴파일되지 않은 `longest` 함수의 구현. 두 문자열 슬라이스 중 더 긴 것을 반환하지만 아직 컴파일되지 않습니다.</span>

대신 다음과 같은 라이프타임에 대한 오류 메시지를 받습니다.

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt}}
```

도움말 텍스트는 반환 유형에 일반적인 라이프타임 매개변수가 필요하다는 것을 알려줍니다. Rust는 반환되는 참조가 `x` 또는 `y`에 참조하는지 알 수 없습니다. 실제로, `if` 블록의 코드에서 `x`에 참조를 반환하고 `else` 블록에서 `y`에 참조를 반환하기 때문에 어느 경우가 실행될지 알 수 없습니다! 함수를 정의할 때는 넣어질 실제 값을 알 수 없기 때문에 `if` 문의 경우나 `else` 문의 경우가 실행될지 알 수 없습니다. 또한, 전달될 참조의 구체적인 라이프타임을 알 수 없기 때문에, 반환되는 참조가 항상 유효할지 여부를 결정할 수 없습니다. 대출 검사기는 이를 알 수 없습니다. 대출 검사기는 반환 값의 라이프타임과 `x`와 `y`의 라이프타임의 관계를 알 수 없기 때문입니다. 이 오류를 해결하려면 대출 검사기가 관계를 파악할 수 있도록 라이프타임 매개변수를 추가하여 정의합니다.

### 라이프타임 표시법

라이프타임 어노테이션은 참조의 수명을 얼마나 오래 유지하는지 바꾸지 않습니다. 오히려, 서로 다른 참조의 라이프타임 관계를 설명하며 라이프타임 자체에 영향을 미치지 않습니다. 함수가 유형 매개변수를 지정할 때 어떤 유형을 받을 수 있듯이, 함수는 라이프타임 매개변수를 지정하여 어떤 라이프타임을 가진 참조를 받을 수 있습니다.

라이프타임 어노테이션은 약간 특이한 문법을 사용합니다. 라이프타임 매개변수의 이름은 맨 앞에  apóstrophe (`'`) 로 시작해야 하며 일반적으로 소문자이고 매우 짧습니다. 대부분의 사람들은 첫 번째 라이프타임 어노테이션에 `'a` 라는 이름을 사용합니다. 라이프타임 매개변수 어노테이션은 참조의 `&` 뒤에 붙여서, 참조 유형과 구분하기 위해 공백을 사용합니다.

다음은 라이프타임 매개변수가 없는 `i32` 참조, `'a` 라는 이름의 라이프타임 매개변수를 가진 `i32` 참조, 그리고 `'a` 라이프타임을 가진 변경 가능한 `i32` 참조입니다.

```rust,ignore
&i32        // 참조
&'a i32     // 명시적인 라이프타임을 가진 참조
&'a mut i32 // 명시적인 라이프타임을 가진 변경 가능한 참조
```

혼자서 사용하는 라이프타임 어노테이션은 의미가 크지 않습니다. 어노테이션은 여러 참조의 일반적인 라이프타임 매개변수가 서로 어떻게 관련되는지 Rust 에 알려주기 위해 사용됩니다. `longest` 함수의 맥락에서 라이프타임 어노테이션이 서로 어떻게 관련되는지 살펴보겠습니다.

### 함수 서명에서의 라이프타임 어노테이션

함수 서명에서 라이프타임 어노테이션을 사용하려면 함수 이름과 매개변수 목록 사이에 각도 괄호 (`<>`) 안에 일반적인 *라이프타임* 매개변수를 선언해야 합니다. 이는 일반적인 *유형* 매개변수와 마찬가지로 합니다.

우리는 반환 참조가 두 매개변수 모두 유효할 때만 유효하도록 서명을 표현하고 싶습니다. 이것이 매개변수의 라이프타임과 반환 값 간의 관계입니다. `'a` 라는 이름을 지정한 후 각 참조에 추가합니다. Listing 10-21 에서 보여주는 것처럼

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-21/src/main.rs:here}}
```

<span class=\"caption\">Listing 10-21: `longest` 함수 정의가 서명에서 모든 참조가 같은 라이프타임 `'a` 를 가져야 한다는 것을 명시합니다.</span>

이 코드는 컴파일되어 `main` 함수와 함께 사용할 때 원하는 결과를 생성합니다. Listing 10-19 에서 확인할 수 있습니다.

함수 서명은 이제 Rust 에 대해 다음과 같은 제약을 명시합니다. 즉, 어떤 라이프타임 `'a` 에 대해 함수는 두 개의 매개변수를 받습니다. 두 매개변수 모두 `'a` 라이프타임 이상으로 유효한 문자열 슬라이스입니다. 함수 서명은 또한 Rust 에 반환되는 문자열 슬라이스가 `'a` 라이프타임 이상으로 유효하다는 것을 알려줍니다.
실제로는 `longest` 함수에서 반환되는 참조의 라이프타임이 함수 인자에 의해 참조되는 값들의 라이프타임 중 더 짧은 것과 같다는 것을 의미합니다. 이러한 관계가 Rust 코드를 분석할 때 원하는 것입니다.

라이프타임 매개변수를 함수 서명에 지정할 때, 우리는 전달되는 값이나 반환되는 값의 라이프타임을 변경하지 않습니다. 오히려 Rust가 이 제약을 따르지 않는 값을 거부하도록 지정하는 것입니다. `longest` 함수가 `x` 와 `y` 가 정확히 얼마나 오래 유지될지 알 필요는 없습니다. 단지 어떤 범위가 `'a` 에 대체되어 이 서명을 충족시킬 수 있는지 알아야 합니다.

함수에 라이프타임 어노테이션을 전달할 때, 어노테이션은 함수 본문이 아닌 함수 서명에 있습니다. 라이프타임 어노테이션은 함수 계약의 일부가 되어, 유형 서명과 마찬가지로 됩니다. 함수 서명에 라이프타임 계약이 포함되어 있으면 Rust 컴파일러가 수행하는 분석이 간단해집니다. 함수가 어떻게 어노테이션되었는지 또는 어떻게 호출되었는지에 문제가 있으면 컴파일러 오류는 코드의 부분과 제약을 더 정확하게 가리킬 수 있습니다. 반대로, Rust 컴파일러가 우리가 라이프타임의 관계를 어떻게 의도했는지에 대해 더 많은 추론을 하면, 컴파일러는 오류를 일으킬 때 우리 코드의 사용 부분을 가리키기보다는 문제의 원인으로부터 멀리 떨어진 부분을 가리킬 수 있습니다.

`longest` 함수에 구체적인 참조를 전달할 때, `'a` 라는 일반적인 라이프타임에 대체되는 구체적인 라이프타임은 `x` 의 범위와 `y` 의 범위가 겹치는 부분입니다. 즉, 일반적인 라이프타임 `'a` 는 `x` 와 `y` 의 범위 중에서 겹치는 부분을 나타내는 구체적인 라이프타임이 됩니다.
 'a'라는 라이프타임 매개변수로 반환되는 참조의 유효 기간이 `x`와 `y`의 라이프타임 중 더 작은 값과 같습니다. 우리가 반환되는 참조에 같은 라이프타임 매개변수 `'a`를 추가로 지정했기 때문에, 반환되는 참조도 `x`와 `y`의 라이프타임 중 더 작은 값만큼 유효합니다.

`longest` 함수가 라이프타임 애너테이션을 통해 어떻게 제한되는지 살펴보겠습니다. 다양한 구체적인 라이프타임을 가진 참조를 전달하는 방법을 살펴보겠습니다. 10-22번 목록은 간단한 예입니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-22/src/main.rs:here}}
```

<span class=\"caption\">Listing 10-22: 다양한 구체적인 라이프타임을 가진 `String` 값의 참조를 사용하는 `longest` 함수</span>

이 예제에서 `string1`은 외부 범위의 끝까지 유효하며, `string2`는 내부 범위의 끝까지 유효하며, `result`는 내부 범위의 끝까지 유효한 것을 참조합니다. 이 코드를 실행하면 보로 체커가 승인하여 컴파일되고 `가장 긴 문자열은 긴 문자열입니다`를 출력합니다.

다음으로, `result` 참조의 라이프타임이 두 개의 인수의 라이프타임 중 더 작은 라이프타임이어야 한다는 것을 보여주는 예제를 살펴보겠습니다. `result` 변수의 선언을 내부 범위 외부로 이동하지만, `string2`에 대한 값을 할당하는 부분은 `string2`가 있는 내부 범위 안에 남겨둡니다. 그런 다음 `println!`을 내부 범위가 끝난 후 외부 범위로 이동합니다. 10-23번 목록의 코드는 컴파일되지 않습니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/src/main.rs:here}}
```

<span class=\"caption\">Listing 10-23: `string2`가 범위를 벗어난 후 `result`를 사용하려는 시도</span>

이 코드를 컴파일하려고 하면 다음과 같은 오류 메시지가 표시됩니다.

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt}}
```

오류 메시지에서 `result`가 `println!` 문에 유효하려면 `string2`가 외부 범위의 끝까지 유효해야 함을 알 수 있습니다. 우리는 `longest` 함수의 인수와 반환 값의 라이프타임을 동일한 라이프타임 매개변수 `'a`로 애너테이션하여 Rust에 이를 알려줍니다.

인간으로서 우리는 이 코드를 보고 `string1`이 `string2`보다 길다는 것을 알 수 있으며, 따라서 `result`는 `string1`을 참조할 것입니다. `string1`은 아직 범위를 벗어나지 않았기 때문에 `string1`에 대한 참조는 여전히 `println!` 문에 유효합니다. 그러나 컴파일러는 이를 알 수 없습니다. 우리는 Rust에 `longest` 함수가 반환하는 참조의 유효 기간이 전달된 참조의 라이프타임 중 더 작은 값과 같다고 알려줍니다. 따라서 보로 체커는 10-23번 목록의 코드를 유효하지 않은 참조를 가질 수 있다는 가능성이 있기 때문에 거부합니다.

`longest` 함수에 전달되는 참조의 값과 라이프타임을 다양하게 변경하여 반환되는 참조가 사용되는 방식에 대한 실험을 설계해 보세요. 컴파일하기 전에 실험이 보로 체커를 통과할지에 대한 가설을 세우고, 맞는지 확인해 보세요!

### 라이프타임을 고려한 사고

함수가 무엇을 하는지에 따라 라이프타임 매개변수를 어떻게 지정해야 하는지가 달라집니다. 예를 들어, `longest` 함수의 구현을 항상 첫 번째 인수를 반환하도록 변경하면 `y` 인수에 대해 라이프타임을 지정할 필요가 없습니다. 다음 코드는 컴파일됩니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-08-only-one-reference-with-lifetime/src/main.rs:here}}
```

`x` 인수와 반환 값에 대해 라이프타임 매개변수 `'a`를 지정했습니다.타입이지만 매개변수 `y`에는 적용되지 않습니다. 왜냐하면 `y`의 수명은 `x` 또는 반환 값의 수명과 관련이 없기 때문입니다.

함수에서 참조를 반환할 때 반환 유형의 수명 매개변수는 매개변수 중 하나의 수명 매개변수와 일치해야 합니다. 반환된 참조가 매개변수 중 하나를 가리키지 않는다면, 해당 참조는 함수 내에서 생성된 값을 가리켜야 합니다. 그러나 이것은 함수가 끝날 때 해당 값이 범위를 벗어나기 때문에 유효하지 않은 참조가 될 것입니다. `longest` 함수의 시도된 구현을 살펴보겠습니다. 이 구현은 컴파일되지 않습니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/src/main.rs:here}}
```

여기서 반환 유형에 대해 `'a`라는 수명 매개변수를 지정했지만, 이 구현은 컴파일되지 않습니다. 왜냐하면 반환 값의 수명은 매개변수의 수명과 전혀 관련이 없기 때문입니다. 다음은 받는 오류 메시지입니다.

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt}}
```

문제는 `result`가 함수의 끝에서 범위를 벗어나 정리되기 때문입니다. 또한 함수에서 `result`에 대한 참조를 반환하려고 합니다. 수명 매개변수를 어떻게 지정하더라도 유효하지 않은 참조를 만들 수 없습니다. Rust는 유효하지 않은 참조를 만들지 못하도록 합니다. 이 경우, 호출하는 함수가 값을 정리할 책임이 되도록 소유된 데이터 유형을 반환하는 것이 가장 좋은 해결책입니다.

결국, 수명 구문은 함수의 다양한 매개변수와 반환 값의 수명을 연결하는 것입니다. 연결되면 Rust는 메모리 안전한 작업을 허용하고 유효하지 않은 포인터를 생성하거나 메모리 안전을 위반하는 작업을 방지할 수 있습니다.

### 구조 정의에서 수명 어노테이션

지금까지 정의한 구조는 모두 소유된 유형을 포함하고 있습니다. 구조에 참조를 포함하도록 정의할 수 있지만, 그렇게 하면 구조 정의의 모든 참조에 대해 수명 어노테이션을 추가해야 합니다. 10-24번 목록에는 `ImportantExcerpt`라는 구조가 있습니다. 이 구조는 문자열 슬라이스를 포함합니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-24/src/main.rs}}
```

<span class=\"caption\">10-24번 목록: `ImportantExcerpt`라는 구조를 포함하는 문자열 슬라이스를 포함하는 구조</span>

이 구조는 `part`라는 하나의 필드를 가지고 있으며 문자열 슬라이스를 포함합니다. 일반 데이터 유형과 마찬가지로 구조 이름 뒤에 각각의 구조 정의 내부에서 사용할 수 있는 수명 매개변수의 이름을 괄호 안에 선언합니다. 이 어노테이션은 `ImportantExcerpt` 인스턴스가 `part` 필드에 포함된 참조보다 오래 살 수 없음을 의미합니다.

`main` 함수는 `novel` 변수가 소유하는 `String`의 첫 번째 문장에 대한 참조를 포함하는 `ImportantExcerpt` 인스턴스를 생성합니다. `novel` 데이터는 `ImportantExcerpt` 인스턴스가 생성되기 전에 존재합니다. 또한 `novel`은 `ImportantExcerpt`이 소멸될 때까지 범위를 벗어나지 않으므로 `ImportantExcerpt` 인스턴스의 참조는 유효합니다.

### 수명 생략

참조에는 항상 수명이 있으며, 참조를 사용하는 함수 또는 구조에 대해 수명 매개변수를 지정해야 합니다. 그러나 4-9번 목록에서 본 함수는 수명 어노테이션 없이 컴파일되었습니다. 10-25번 목록에 다시 표시된 함수입니다.

<span class=\"filename\">Filename: src/lib.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-25/src/main.rs:here}}
```

<span class=\"caption\">10-25번 목록: 4-9번 목록에서 정의한 함수를 다시 표시합니다. 매개변수와 반환 유형이 참조이지만 수명 어노테이션 없이 컴파일되었습니다.</span>

이 함수가 수명 어노테이션 없이 컴파일되는 이유는 역사적인 이유 때문입니다.초기 버전(1.0 이전)의 Rust에서는 이 코드가 컴파일되지 않았을 것입니다. 모든 참조가 명시적인 수명을 필요로 했기 때문입니다. 당시 함수 선언은 다음과 같이 작성되었을 것입니다.

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

많은 Rust 코드를 작성한 후 Rust 개발팀은 Rust 프로그래머들이 특정 상황에서 반복적으로 동일한 수명 어노테이션을 입력하고 있음을 발견했습니다. 이러한 상황은 예측 가능하며 몇 가지 결정론적인 패턴을 따르고 있었습니다. 개발자들은 이러한 패턴을 컴파일러 코드에 프로그래밍하여 보로 체커가 이러한 상황에서 수명을 유추하고 명시적인 어노테이션이 필요하지 않도록 했습니다.

이 Rust 역사는 앞으로 더 많은 결정론적인 패턴이 나타나고 컴파일러에 추가될 수 있다는 가능성이 있기 때문에 중요합니다. 미래에는 더 적은 수명 어노테이션이 필요할 수 있습니다.

Rust의 참조 분석에 프로그래밍된 패턴을 *수명 생략 규칙*이라고 합니다. 이는 프로그래머가 따르는 규칙이 아니라, 컴파일러가 고려하는 특정 사례의 집합이며, 코드가 이러한 사례에 맞으면 수명을 명시적으로 작성할 필요가 없습니다.

생략 규칙은 완전한 유추를 제공하지 않습니다. Rust가 규칙을 적용한 후에도 참조의 수명에 대한 모호성이 남아 있다면, 컴파일러는 나머지 참조의 수명이 무엇이어야 하는지 추측하지 않습니다. 추측 대신, 컴파일러는 수명 어노테이션을 추가하여 해결할 수 있는 오류를 표시합니다.

함수 또는 메서드 매개변수의 수명을 *입력 수명*이라고 하고, 반환 값의 수명을 *출력 수명*이라고 합니다.

컴파일러는 명시적인 어노테이션이 없는 경우 참조의 수명을 파악하기 위해 세 가지 규칙을 사용합니다. 첫 번째 규칙은 입력 수명에 적용되며, 두 번째 및 세 번째 규칙은 출력 수명에 적용됩니다. 컴파일러가 세 가지 규칙을 모두 처리했지만 여전히 수명을 파악할 수 없는 참조가 있다면, 컴파일러는 오류를 발생시킵니다. 이러한 규칙은 `fn` 정의뿐만 아니라 `impl` 블록에도 적용됩니다.

첫 번째 규칙은 각 참조 매개변수에 수명 매개변수를 할당한다는 것입니다. 즉, 하나의 매개변수를 가진 함수는 하나의 수명 매개변수를 얻습니다: `fn foo<'a>(x: &'a i32)`; 두 개의 매개변수를 가진 함수는 두 개의 별도의 수명 매개변수를 얻습니다: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; 이와 같이 됩니다.

두 번째 규칙은 입력 수명 매개변수가 정확히 하나인 경우에 적용됩니다. 두 번째 규칙은 하나의 입력 매개변수의 수명이 출력 수명 매개변수에 할당된다는 것을 명시합니다: `fn foo<'a>(x: &'a i32) -> &'a i32`.

세 번째 규칙은 입력 수명 매개변수가 여러 개 있지만 `&self` 또는 `&mut self` 중 하나가 아닌 경우(즉, 메서드인 경우)에 적용됩니다. 세 번째 규칙은 `self`의 수명이 모든 출력 수명 매개변수에 할당된다는 것을 의미합니다. 이 세 번째 규칙은 메서드를 읽고 쓰는 데 있어서 더 적은 기호가 필요하기 때문에 메서드를 훨씬 더 읽기 쉽고 쓸 수 있게 합니다.

Listing 10-25의 `first_word` 함수의 시그니처에서 참조의 수명을 파악하기 위해 컴파일러가 되어 보겠습니다. 시그니처는 처음에는 참조에 수명이 연결되지 않았습니다.

```rust,ignore
fn first_word(s: &str) -> &str {
```

그런 다음 컴파일러는 각 매개변수에 하나의 수명을 할당하는 첫 번째 규칙을 적용합니다. 우리는 일반적으로 `'a`라고 부르므로 시그니처가 이렇게 됩니다.

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

입력 매개변수가 하나만 있기 때문에 두 번째 규칙이 적용됩니다. 두 번째 규칙은 입력 매개변수의 수명이 출력 수명에 할당된다는 것을 명시합니다. 따라서 시그니처가 이렇게 됩니다.

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

이제 이 함수 시그니처의 모든 참조에 수명이 할당되었으며, 컴파일러는 이 함수 시그니처를 분석하는 데 필요한 모든 정보를 가지고 있습니다.

다른 예를 살펴보겠습니다. 이번에는 Listing 10-20에서 처음 작업했던 `longest` 함수를 사용합니다.

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

첫 번째 규칙을 적용하면 각 매개변수에 하나의 수명이 할당됩니다. 이번에는 하나의 매개변수가 아니라 두 개의 매개변수가 있으므로 두 개의 수명이 있습니다.

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

여기서 두 번째 규칙이 적용되지 않습니다. 입력 라이프타임이 하나 이상이기 때문입니다. 세 번째 규칙 또한 적용되지 않습니다. `longest`가 함수이기 때문에 `self`가 아닌 매개변수이기 때문입니다. 세 가지 규칙을 모두 검토한 후에도 반환 유형의 라이프타임이 무엇인지 아직 알 수 없습니다. 이것이 Listing 10-20의 코드를 컴파일할 때 오류가 발생한 이유입니다. 컴파일러는 라이프타임 생략 규칙을 처리했지만, 함수 선언의 참조의 모든 라이프타임을 파악할 수 없었습니다.

세 번째 규칙은 실제로 메서드 선언에서만 적용되므로, 메서드 선언에서 라이프타임을 살펴보겠습니다. 세 번째 규칙이 메서드 선언에서 라이프타임을 지정할 필요가 거의 없다는 것을 알 수 있습니다.

### 메서드 정의에서의 라이프타임 어노테이션

구조체에 라이프타임을 사용하여 메서드를 구현할 때는 Listing 10-11과 같은 일반적인 유형 매개변수의 문법을 사용합니다. 라이프타임 매개변수를 선언하고 사용하는 위치는 구조체 필드와 메서드 매개변수 및 반환 값과 관련이 있는지 여부에 따라 다릅니다.

구조체 필드의 라이프타임 이름은 항상 `impl` 키워드 뒤에 선언되어야 하며, 구조체 이름 뒤에 사용되어야 합니다. 이러한 라이프타임은 구조체의 유형의 일부이기 때문입니다.

`impl` 블록 내의 메서드 선언에서 참조는 구조체 필드의 참조의 라이프타임과 연결될 수 있거나 독립적일 수 있습니다. 또한, 라이프타임 생략 규칙은 메서드 선언에서 라이프타임 어노테이션이 필요하지 않게 만드는 경우가 많습니다. Listing 10-24에서 정의한 `ImportantExcerpt`이라는 구조체를 사용하여 몇 가지 예를 살펴보겠습니다.

먼저 `level`이라는 메서드를 사용합니다. 이 메서드의 유일한 매개변수는 `self`에 대한 참조이며, 반환 값은 `i32`입니다. `i32`는 어떤 것의 참조가 아니므로:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:1st}}
```

`impl` 뒤에 라이프타임 매개변수 선언과 유형 이름 뒤에 사용하는 것은 필수적이지만, `self`에 대한 참조의 라이프타임을 어노테이션할 필요는 없습니다. 첫 번째 생략 규칙 때문입니다.

다음은 세 번째 라이프타임 생략 규칙이 적용되는 예입니다.

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:3rd}}
```

두 개의 입력 라이프타임이 있으므로 Rust은 첫 번째 라이프타임 생략 규칙을 적용하고 `&self`와 `announcement`에 각각 자신의 라이프타임을 부여합니다. 그런 다음 `&self`의 매개변수 중 하나도 `&self`이 아니기 때문에 반환 유형은 `&self`의 라이프타임을 얻게 되고, 모든 라이프타임이 처리되었습니다.

### 정적 라이프타임

우리가 논의해야 할 특별한 라이프타임은 `'static`입니다. `'static`는 영향을 미치는 참조가 프로그램 전체 기간 동안 살아있을 수 있다는 것을 나타냅니다. 모든 문자열 리터럴은 `'static` 라이프타임을 가지고 있으며, 다음과 같이 어노테이션할 수 있습니다.

```rust
let s: &'static str = \"I have a static lifetime.\";
```

이 문자열의 텍스트는 프로그램 바이너리에 직접 저장되므로 항상 사용할 수 있습니다. 따라서 모든 문자열 리터럴의 라이프타임은 `'static`입니다.

오류 메시지에서 `'static` 라이프타임을 사용하도록 제안하는 것을 볼 수 있습니다. 그러나 참조에 대해 `'static` 라이프타임을 지정하기 전에, 실제로 프로그램 전체 기간 동안 유효한 참조인지, 그리고 그렇게 하려는지 생각해야 합니다. 대부분의 경우 `'static` 라이프타임을 제안하는 오류 메시지는 dangling 참조를 만들거나 라이프타임이 일치하지 않기 때문입니다. 이러한 경우 해결책은 문제를 해결하는 것입니다. `'static` 라이프타임을 지정하는 것입니다.

## 일반 유형 매개변수, 트레이트 경계, 그리고 라이프타임의 조합

일반 유형 매개변수, 트레이트 경계, 그리고 라이프타임을 모두 한 번에 지정하는 문법을 간단히 살펴보겠습니다.

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}
```

이는 Listing 10-21의 `longest` 함수로, `&str`의 더 긴 것을 반환합니다.두 개의 문자열 슬라이스입니다. 하지만 이제 `ann`이라는 이름의 추가 매개변수가 있으며, `Display` 트레이트를 구현하는 모든 유형으로 채울 수 있는 일반적인 유형 `T`입니다. `where` 절에 의해 지정된 것처럼. 이 추가 매개변수는 `{}`를 사용하여 인쇄되므로 `Display` 트레이트 경계가 필요합니다. 라이프타임은 일반 유형의 한 종류이기 때문에 라이프타임 매개변수 `'a`와 일반 유형 매개변수 `T`의 선언은 함수 이름 뒤 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각의 각각