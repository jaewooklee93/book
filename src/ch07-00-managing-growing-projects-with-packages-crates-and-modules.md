## 패키지, 크레이트 및 모듈을 사용하여 증가하는 프로젝트 관리

크게 프로그램을 작성할 때 코드를 정리하는 것이 점점 더 중요해집니다. 관련 기능을 그룹화하고 구분된 기능으로 코드를 분리하면 특정 기능을 구현하는 코드를 찾고 그 기능이 어떻게 작동하는지 변경하는 위치를 명확하게 파악할 수 있습니다.

지금까지 작성한 프로그램은 하나의 파일에서 하나의 모듈에 있었습니다. 프로젝트가 커질수록 여러 모듈과 여러 파일로 코드를 분할하여 정리해야 합니다. 패키지는 여러 바이너리 크레이트와 선택적으로 하나의 라이브러리 크레이트를 포함할 수 있습니다. 패키지가 커지면 별도의 크레이트로 추출하여 외부 의존성으로 만들 수 있습니다. 이 장에서는 이러한 모든 기술을 다룹니다. 관련된 패키지 집합으로 구성된 매우 큰 프로젝트의 경우 Cargo는 *작업 공간*을 제공하며, 이는 제14장의 [\u201cCargo 작업 공간\u201d][workspaces]<!-- ignore --> 섹션에서 다룹니다.

또한 구현 세부 사항을 캡슐화하는 방법에 대해 설명합니다. 이를 통해 고급 수준에서 코드를 재사용할 수 있습니다. 특정 작업을 구현한 후 다른 코드는 구현 방식을 알지 못하고도 공개 인터페이스를 통해 코드를 호출할 수 있습니다. 코드를 작성하는 방식은 다른 코드가 사용할 수 있는 공개 부분과 구현 세부 사항(변경할 권리가 있는)이라는 사실을 정의합니다. 이는 머릿속에 유지해야 하는 세부 사항의 양을 제한하는 또 다른 방법입니다.

범위라는 관련 개념은 코드가 작성되는 중첩된 맥락에서 정의된 이름의 집합입니다. 읽고 작성하고 코드를 컴파일할 때 프로그래머와 컴파일러는 특정 위치에서 특정 이름이 변수, 함수, 구조체, 열거형, 모듈, 상수 또는 다른 항목을 가리키는지, 그리고 그 항목이 무엇을 의미하는지 알아야 합니다. 범위를 만들고 어떤 이름이 포함되고 있는지 변경할 수 있습니다. 동일한 범위 내에서 동일한 이름을 가진 항목을 두 개를 가질 수 없습니다. 도구는 이름 충돌을 해결하는 데 사용됩니다.

Rust는 코드의 구성을 관리하는 데 사용할 수 있는 여러 가지 기능을 제공하며, 노출되는 세부 사항, 개인적인 세부 사항 및 프로그램의 각 범위에 있는 이름을 포함합니다. 이러한 기능은 때때로 *모듈 시스템*이라고 총칭되며 다음과 같습니다.

* **패키지:** Cargo 기능으로 크레이트를 빌드, 테스트 및 공유할 수 있도록 합니다.
* **크레이트:** 라이브러리 또는 실행 가능한 파일을 생성하는 모듈 트리
* **모듈** 및 **use:** 경로의 구성, 범위 및 개인 접근 제어를 사용합니다.
* **경로:** 구조체, 함수 또는 모듈과 같은 항목을 명명하는 방법

이 장에서는 이러한 모든 기능을 다룹니다. 상호 작용하는 방식을 설명하고 범위를 관리하는 방법을 이해하도록 돕습니다. 이 장을 마치면 모듈 시스템에 대한 견고한 이해를 갖고 범위를 전문가처럼 다룰 수 있을 것입니다!

[workspaces]: ch14-03-cargo-workspaces.html
