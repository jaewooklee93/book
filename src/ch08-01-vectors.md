## 벡터를 사용하여 값 목록 저장하기

첫 번째로 살펴볼 컬렉션 유형은 `Vec<T>` 또는 *벡터*입니다.
벡터는 메모리에 모든 값을 서로 붙여서 저장할 수 있는 단일 데이터 구조에 여러 값을 저장할 수 있도록 합니다.
벡터는 동일한 유형의 값만 저장할 수 있습니다. 파일의 줄이나 장바구니의 상품 가격과 같은 항목 목록이 있을 때 유용합니다.

### 새 벡터 만들기

새 비어 있는 벡터를 만들려면 `Vec::new` 함수를 호출합니다. Listing 8-1과 같이

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-01/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-1: `i32` 유형의 값을 저장하는 새 비어 있는 벡터를
만드는 것</span>

여기서 유형 지정을 추가했습니다. 이 벡터에 값을 삽입하지 않기 때문에 Rust는 우리가 저장하려는 유형의 요소를 알지 못합니다. 이는 중요한 점입니다. 벡터는 제네릭을 사용하여 구현됩니다. 제네릭을 사용하여 자신의 유형으로 제네릭을 사용하는 방법은 제10장에서 다룹니다. 지금은 `Vec<T>`가 표준 라이브러리에서 제공하는 유형이 어떤 유형의 값을 저장할 수 있는지 알고 있습니다. 특정 유형의 값을 저장하는 벡터를 만들 때는 각각의 유형을 괄호 안에 지정할 수 있습니다. Listing 8-1에서 `v`의 `Vec<T>`는 `i32` 유형의 요소를 저장할 것이라고 Rust에 알렸습니다.

더 자주는 초기 값을 가진 `Vec<T>`를 만들고 Rust는 저장하려는 값의 유형을 추론하므로 이 유형 지정을 거의 필요하지 않습니다. Rust는 편리하게 `vec!` 매크로를 제공하며, 제공하는 값으로 새로운 벡터를 생성합니다. Listing 8-2는 `1`, `2`, `3` 값을 포함하는 새로운 `Vec<i32>`를 만듭니다. 정수 유형은 `i32`이기 때문에 제3장의 [\u201c데이터 유형\u201d][data-types]<!-- ignore --> 섹션에서 논의했듯이 기본 정수 유형입니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-02/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-2: 값을 포함하는 새로운 벡터를 만드는 것</span>

초기 `i32` 값을 제공했기 때문에 Rust는 `v`의 유형이 `Vec<i32>`라고 추론할 수 있으며 유형 지정이 필요하지 않습니다. 다음으로 벡터를 수정하는 방법을 살펴보겠습니다.

### 벡터 업데이트하기

벡터를 만들고 값을 추가하려면 `push` 메서드를 사용할 수 있습니다. Listing 8-3과 같이

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-03/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-3: `push` 메서드를 사용하여 벡터에 값을 추가하는 것</span>

변수와 마찬가지로 값을 변경할 수 있도록 `mut` 키워드를 사용해야 합니다. 제3장에서 논의했듯이
`i32` 유형의 숫자를 넣으면 Rust는 이를 추론하므로 유형 지정이 필요하지 않습니다.

### 벡터 요소 읽기

벡터에 저장된 값에 참조하는 방법은 인덱싱 또는 `get` 메서드를 사용하는 두 가지가 있습니다. 다음 예제에서는 함수에서 반환되는 값의 유형을 명확하게 하기 위해 유형을 지정했습니다.

Listing 8-4는 인덱싱 문법과 `get` 메서드를 사용하여 벡터의 값에 액세스하는 두 가지 방법을 보여줍니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-04/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-4: 인덱싱 문법과 `get` 메서드를 사용하여 벡터의
요소에 액세스하는 것</span>

여기 몇 가지 세부 사항에 주의하십시오. 인덱스 값 `2`를 사용하여 0부터 시작하는 인덱스 번호로 3번째 요소를 가져옵니다. `&`와 `[]`를 사용하면 인덱스 값에 있는 요소에 대한 참조를 얻습니다. `get` 메서드는 인덱스 값에 해당하는 요소를 반환하는 데 사용됩니다. `get` 메서드는 `None`을 반환할 수 있습니다. 이는 인덱스가 벡터 범위를 벗어났을 때 발생합니다. `get` 메서드를 사용하려면 `Option<T>`을 사용하여 결과를 처리해야 합니다. `Option<T>`은 `Some(T)` 또는 `None`을 나타내는 옵셔널 유형입니다. `Some(T)`는 `T` 유형의 값을 포함하는 옵셔널입니다. `None`은 값이 없는 옵셔널입니다. `Option<T>`을 사용하여 `get` 메서드의 결과를 처리하면 `None`을 반환하는 경우 오류를 방지할 수 있습니다.

인덱스를 인자로 전달하는 메서드를 사용하면 `Option<&T>`를 얻을 수 있으며, 이를 `match`를 사용하여 처리할 수 있습니다.

Rust는 요소에 참조하는 두 가지 방법을 제공하여 프로그램이 존재하지 않는 인덱스 값을 사용하려고 할 때 어떻게 동작할지 선택할 수 있습니다. 예를 들어, 5개의 요소가 있는 벡터가 있고 인덱스 100의 요소에 액세스하려고 할 때 각 기술이 어떻게 작동하는지 살펴보겠습니다. (Listing 8-5 참조)

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-05/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-5: 5개의 요소를 포함하는 벡터에서 인덱스 100의 요소에 액세스하려는 시도</span>

이 코드를 실행하면 첫 번째 `[]` 메서드는 존재하지 않는 요소에 참조하기 때문에 프로그램이 panic하게 됩니다. 이 메서드는 벡터의 끝을 넘어서는 요소에 액세스하려는 시도가 있을 때 프로그램이 충돌하도록 원하는 경우에 가장 적합합니다.

`get` 메서드에 벡터 범위를 벗어난 인덱스가 전달되면 `None`을 반환하지만 panic하지 않습니다. 벡터의 범위를 벗어난 요소에 액세스하는 것이 일반적인 상황에서 때때로 발생할 수 있는 경우에 이 메서드를 사용합니다. 코드는 `Some(&element)` 또는 `None` 중 하나를 가질 수 있는지에 대한 논리를 처리해야 합니다. (Chapter 6 참조)
예를 들어, 인덱스는 사용자가 숫자를 입력하는 것에서 나올 수 있습니다. 사용자가 실수로 너무 큰 숫자를 입력하고 프로그램이 `None` 값을 얻으면 사용자에게 현재 벡터에 있는 항목의 개수를 알리고 유효한 값을 다시 입력하도록 할 수 있습니다. 이렇게 하면 프로그램이 잘못된 입력으로 인해 충돌하는 것보다 사용자 친화적입니다!

프로그램에 유효한 참조가 있으면, 보로우 체커(Chapter 4에서 다루었습니다)는 이 참조와 벡터의 내용에 대한 다른 모든 참조가 유효하도록 소유권과 대여 규칙을 강제합니다. 첫 번째 요소에 대한 불변 참조를 갖고 있는 벡터에서 요소를 추가하려는 경우에 있는 Listing 8-6을 생각해 보세요. 이 프로그램은 함수 내에서 나중에 해당 요소를 참조하려고 하면 작동하지 않습니다.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-06/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-6: 벡터의 첫 번째 요소에 참조를 가질 때 요소를 추가하려는 시도</span>

이 코드를 컴파일하면 다음과 같은 오류가 발생합니다:

```console
{{#include ../listings/ch08-common-collections/listing-08-06/output.txt}}
```

Listing 8-6의 코드는 작동해야 할 것처럼 보입니다. 첫 번째 요소에 대한 참조가 벡터의 끝에서의 변경 사항에 신경 쓰는 이유는 무엇일까요? 이 오류는 벡터가 작동하는 방식 때문입니다. 벡터는 메모리에 값을 서로 인접하게 저장하기 때문에, 벡터의 끝에 새로운 요소를 추가하면 충분한 공간이 없으면 새 메모리 할당 및 기존 요소를 새 공간으로 복사해야 할 수 있습니다. 그런 경우, 첫 번째 요소에 대한 참조는 해제된 메모리에 가리키게 됩니다. 보로우 규칙은 프로그램이 이러한 상황에 빠지지 않도록 방지합니다.

> 참고: `Vec<T>` 유형의 구현 세부 정보에 대해서는 [\u201cThe Rustonomicon\u201d][nomicon]을 참조하십시오.

### 벡터의 값을 순회하는 방법

벡터의 각 요소에 하나씩 액세스하려면, 인덱스를 사용하여 하나씩 액세스하는 대신 모든 요소를 순회하는 것이 좋습니다. Listing 8-7은 `i32` 값을 가진 벡터의 각 요소에 불변 참조를 얻고 출력하는 방법을 보여줍니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-07/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-7: `for` 루프를 사용하여 `i32` 값을 가진 벡터의 각 요소를 출력하는 방법</span>

변수 벡터의 각 요소에 대한 가변 참조를 순회하여 모든 요소에 변경 사항을 적용하는 방법도 있습니다. Listing 8-8은 가변 참조를 가진 각 요소를 순회하는 `for` 루프를 보여줍니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-08/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-8: 가변 참조를 가진 각 요소를 순회하여 벡터의 각 요소를 변경하는 방법</span>

벡터의 각 요소에 `50`을 추가합니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-08/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-8: 변경 가능한 참조를 사용하여 벡터 요소를 반복</span>

변경 가능한 참조가 가리키는 값을 변경하려면 `*` 해제 연산자를 사용하여 `i` 안의 값에 접근해야 합니다. 그런 다음 `+=` 연산자를 사용할 수 있습니다. 해제 연산자에 대해서는 제15장의 \"해제 연산자를 사용하여 값에 대한 포인터를 따라가기\" 섹션에서 자세히 설명합니다.

무결성 또는 변경 가능성을 사용하여 벡터를 반복하는 것은 대출 검사기의 규칙 덕분에 안전합니다. Listing 8-7과 Listing 8-8에서 `for` 루프 몸체에 요소를 삽입하거나 제거하려고 시도하면 Listing 8-6의 코드와 유사한 컴파일러 오류가 발생합니다. `for` 루프가 가진 벡터 참조는 전체 벡터의 동시 수정을 방지합니다.

### 여러 유형을 저장하기 위한 `enum` 사용

벡터는 동일한 유형의 값만 저장할 수 있습니다. 이는 때때로 불편할 수 있습니다. 다양한 유형의 항목 목록을 저장해야 하는 경우가 있습니다. 다행히 `enum`의 변형은 동일한 `enum` 유형 아래에서 정의되므로, 다양한 유형을 나타내는 하나의 유형이 필요할 때 `enum`을 정의하고 사용할 수 있습니다!

예를 들어, 일부 열이 정수, 일부는 부동 소수점 숫자, 일부는 문자열을 포함하는 스프레드시트의 행에서 값을 가져오려고 한다면, 다양한 값 유형을 담을 수 있는 `enum`을 정의할 수 있습니다. 모든 `enum` 변형은 해당 `enum`의 유형으로 간주되므로, 해당 `enum`을 포함하는 벡터를 만들고 마침내 다양한 유형을 저장할 수 있습니다. Listing 8-9에서 이것을 보여줍니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-09/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-9: 다양한 유형을 저장하는 벡터에 `enum`을 정의</span>

Rust는 컴파일 시간에 벡터에 포함될 유형을 알아야 하므로 각 요소를 저장하기 위해 헤프에 얼마나 많은 메모리가 필요한지 정확히 알 수 있습니다. 또한 Rust는 이 벡터에 허용되는 유형에 대해 명시적으로 알려야 합니다. Rust가 벡터에 모든 유형을 허용한다면, 벡터 요소에 대해 수행되는 작업으로 인해 하나 이상의 유형이 오류를 일으킬 수 있습니다. `enum`과 `match` 표현식을 사용하면 Rust가 제6장에서 논의한 것처럼 컴파일 시간에 모든 가능한 경우가 처리되도록 보장합니다.

프로그램이 런타임에 저장할 벡터에 대한 완전한 유형 세트를 알지 못하는 경우 `enum` 기법은 작동하지 않습니다. 대신 트레이트 객체를 사용할 수 있습니다. 트레이트 객체는 제17장에서 다룹니다.

이제 벡터의 가장 일반적인 사용 방법에 대해 논의했으므로, 표준 라이브러리에서 `Vec<T>`에 정의된 많은 유용한 메서드에 대한 [API 문서](../std/vec/struct.Vec.html)를 참조하십시오. 예를 들어, `push` 외에도 `pop` 메서드는 마지막 요소를 제거하고 반환합니다.

### 벡터를 삭제하면 요소도 삭제됩니다.

`struct`와 마찬가지로 벡터는 범위가 끝나면 해제됩니다. Listing 8-10에서 설명되어 있습니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-10/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-10: 벡터와 그 요소가 삭제되는 위치를 보여주기</span>

벡터가 해제되면 그 안에 있는 모든 내용도 해제되므로, 저장된 정수는 정리됩니다. 대출 검사기는 벡터 자체가 유효한 동안 벡터의 내용에 대한 모든 참조가 사용되도록 보장합니다.

다음 컬렉션 유형인 `String`으로 넘어가겠습니다!

deref: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator
