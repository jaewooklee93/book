## 해시맵을 사용하여 키와 관련된 값 저장하기

우리의 일반적인 자료구조 중 마지막은 *해시맵*입니다. `HashMap<K, V>` 유형은 *해싱 함수*를 사용하여 `K` 유형의 키와 `V` 유형의 값을 저장하는 매핑을 저장합니다. 해싱 함수는 이러한 키와 값을 메모리에 어떻게 배치할지 결정합니다.
많은 프로그래밍 언어가 이러한 유형의 데이터 구조를 지원하지만, 종종 *해시*, *맵*, *객체*, *해시 테이블*, *사전*, *연관 배열*과 같은 다른 이름을 사용합니다.

해시맵은 인덱스를 사용하여 데이터를 검색하는 것과 달리, 어떤 유형의 키를 사용하여 데이터를 검색할 때 유용합니다. 예를 들어 게임에서 각 팀의 점수를 해시맵에 저장할 수 있습니다. 각 키는 팀 이름이고 값은 각 팀의 점수입니다. 팀 이름이 주어지면 해당 점수를 검색할 수 있습니다.

이 섹션에서는 해시맵의 기본 API를 살펴보겠지만, 표준 라이브러리에서 정의된 `HashMap<K, V>` 함수에는 더 많은 기능이 있습니다. 자세한 내용은 표준 라이브러리 문서를 참조하십시오.

### 새로운 해시맵 만들기

빈 해시맵을 만드는 한 가지 방법은 `new`를 사용하고 `insert`로 요소를 추가하는 것입니다. 8-20번 목록에서는 *Blue*와 *Yellow* 두 팀의 점수를 추적하고 있습니다. Blue 팀은 10점으로 시작하고 Yellow 팀은 50점으로 시작합니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-20/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-20: 새로운 해시맵 만들고 키와 값 삽입하기</span>

표준 라이브러리의 `HashMap`을 사용하려면 `use`해야 합니다. 세 가지 일반적인 자료구조 중에서 가장 적게 사용되므로, 기본적으로 사용 범위에 포함되지 않습니다.
해시맵은 표준 라이브러리에서의 지원도 적습니다. 예를 들어, 해시맵을 생성하는 데 사용되는 내장 매크로가 없습니다.

벡터와 마찬가지로 해시맵은 힙에 데이터를 저장합니다. 이 `HashMap`은 `String` 유형의 키와 `i32` 유형의 값을 가지고 있습니다. 벡터와 마찬가지로 해시맵은 동질적입니다. 모든 키는 동일한 유형이어야 하며, 모든 값은 동일한 유형이어야 합니다.

### 해시맵에서 값 액세스하기

키를 `get` 메서드에 제공하면 해시맵에서 값을 가져올 수 있습니다. 8-21번 목록에서 보여주듯이.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-21/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-21: 해시맵에 저장된 Blue 팀의 점수 액세스하기</span>

여기서 `score`는 Blue 팀과 관련된 값을 가지고 있으며, 결과는 `10`입니다. `get` 메서드는 `Option<&V>`를 반환합니다. 해시맵에 해당 키에 대한 값이 없으면 `get`은 `None`을 반환합니다. 이 프로그램은 `Option`을 `copied`를 호출하여 `Option<i32>`를 가져오고 `unwrap_or`를 사용하여 `scores`에 키가 없으면 `score`를 0으로 설정합니다.

`for` 루프를 사용하여 해시맵의 각 키-값 쌍을 순회할 수 있습니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-03-iterate-over-hashmap/src/main.rs:here}}
```

이 코드는 임의의 순서로 각 쌍을 출력합니다.

```text
Yellow: 50
Blue: 10
```

### 해시맵과 소유권

`Copy` 트레이트를 구현하는 유형(예: `i32`)의 경우, 값이 해시맵으로 복사됩니다. `String`과 같은 소유된 값의 경우, 값이 이동되고 해시맵이 해당 값의 소유자가 됩니다. 8-22번 목록에서 보여주듯이.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-22/src/main.rs:here}}
```

## 해시맵에서 값 업데이트하기

해시맵은 키와 값의 쌍을 저장하는데, 각 고유한 키는 한 번에 하나의 값만 할당받을 수 있습니다. (반대로는 할당받을 수 없습니다. 예를 들어, 파란팀과 노란팀은 모두 `scores` 해시맵에 `10`이라는 값이 저장될 수 있습니다.)

해시맵의 데이터를 변경하려면, 이미 키에 값이 할당된 경우를 어떻게 처리할지 결정해야 합니다. 기존 값을 새 값으로 바꿀 수 있습니다. 기존 값을 무시하고 새 값만 추가할 수도 있습니다. 또는 기존 값과 새 값을 결합할 수도 있습니다. 각 방법을 살펴보겠습니다!

### 값 덮어쓰기

해시맵에 키와 값을 삽입한 후 동일한 키를 다른 값과 함께 다시 삽입하면 해당 키와 연결된 값이 바뀝니다. 8-23번 목록의 코드는 `insert`를 두 번 호출하지만, 해시맵에는 파란팀의 키에 대한 값만 하나 저장됩니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-23/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-23: 특정 키로 저장된 값을 대체하는 방법</span>

이 코드는 `{\"Blue\": 25}`를 출력합니다. 원래 값인 `10`이 덮어쓰였습니다.

### 키가 존재하지 않을 때만 값 추가하기

해시맵에 특정 키가 이미 값과 함께 있는지 확인하고, 키가 존재하면 기존 값을 유지하고, 키가 존재하지 않으면 키와 값을 추가하는 것은 일반적인 작업입니다.

해시맵은 `entry`라는 특수한 API를 제공하여 이 작업을 수행합니다. `entry` 메서드는 확인하려는 키를 매개변수로 받습니다. `entry` 메서드의 반환값은 `Entry`라는 enum으로, 키가 존재하는지 여부를 나타냅니다. 예를 들어, 노란팀의 키에 값이 할당되어 있는지 확인하고, 값이 없으면 `50`을 할당하고 싶다고 가정해 봅시다. `entry` API를 사용하면 코드는 8-24번 목록과 같습니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-24/src/main.rs:here}}
```

<span class=\"caption\">Listing 8-24: 키가 이미 존재하지 않을 때만 값을 추가하는 방법</span>

`or_insert` 메서드는 `Entry`에 정의되어 있으며, 해당 키에 대한 값이 이미 존재하면 해당 값에 대한 가변 참조를 반환하고, 존재하지 않으면 매개변수를 새 값으로 삽입하고 새 값에 대한 가변 참조를 반환합니다. 이 기술은 직접 논리를 작성하는 것보다 깔끔하며, 대출 검사기와 더 잘 작동합니다.

8-24번 목록의 코드를 실행하면 `{\"Yellow\": 50, \"Blue\": 10}`가 출력됩니다. 첫 번째 `entry` 호출은 노란팀의 키에 `50`이라는 값을 삽입합니다. 노란팀은 이미 값이 없기 때문입니다. 두 번째 `entry` 호출은 해시맵을 변경하지 않습니다. 파란팀은 이미 `10`이라는 값을 가지고 있기 때문입니다.

#### 기존 값 기반으로 값 업데이트

해시 맵의 또 다른 일반적인 사용 사례는 키의 값을 검색하고 기존 값을 기반으로 업데이트하는 것입니다. 예를 들어, 8-25번째 표는 텍스트에서 각 단어가 몇 번 나타나는지 세는 코드를 보여줍니다. 단어를 키로 사용하고 몇 번 봤는지 추적하기 위해 값을 증가시키는 해시 맵을 사용합니다. 처음에 특정 단어를 본 경우에는 `0`을 먼저 삽입합니다.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-25/src/main.rs:here}}
```

<span class=\"caption\">8-25번째 표: 단어와 횟수를 저장하는 해시 맵을 사용하여 단어의 발생 횟수를 세기</span>

이 코드는 `{\"world\": 2, \"hello\": 1, \"wonderful\": 1}`을 출력합니다. 동일한 키-값 쌍이 다른 순서로 출력될 수 있습니다. 해시 맵을 순회하는 것은 임의의 순서로 일어나기 때문입니다. ([\u201c해시 맵에서 값 액세스\u201d][access]<!-- ignore --> 섹션 참조)

`split_whitespace` 메서드는 텍스트 값의 공백으로 분리된 부분 문자열에 대한 이터레이터를 반환합니다. `or_insert` 메서드는 지정된 키에 대한 값에 대한 변경 가능한 참조 (`&mut V`)를 반환합니다. 여기서는 해당 변경 가능한 참조를 `count` 변수에 저장하므로 값에 할당하려면 `count`를 별표 (`*`)를 사용하여 해제해야 합니다. 변경 가능한 참조는 `for` 루프의 끝에서 스코프가 종료되므로 이러한 모든 변경 사항은 안전하며 대출 규칙에 따라 허용됩니다.

### 해싱 함수

`HashMap`은 기본적으로 DoS 공격(해시 테이블[^siphash]<!-- ignore -->에 대한)에 대한 저항력을 제공할 수 있는 *SipHash*라는 해싱 함수를 사용합니다. 가장 빠른 해싱 알고리즘은 아니지만, 성능 저하와 함께 제공되는 보안 향상은 그만큼 가치가 있습니다. 코드를 프로파일링하여 기본 해싱 함수가 목적에 너무 느리다면, `BuildHasher` 트레이트를 구현하는 타입인 다른 함수로 전환할 수 있습니다. 트레이트와 구현 방법은 [Chapter 10][traits]<!-- ignore -->에서 다룹니다. 직접 해싱 함수를 구현해야 할 필요는 없습니다. [crates.io](https://crates.io/)<!-- ignore -->에는 많은 일반적인 해싱 알고리즘을 구현하는 해싱 함수를 공유하는 다른 Rust 사용자의 라이브러리가 있습니다.

[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)

## 요약

벡터, 문자열 및 해시 맵은 데이터를 저장하고 액세스하고 수정해야 할 때 프로그램에서 필요한 많은 기능을 제공합니다. 이제 해결할 준비가 되어 있는 몇 가지 연습 문제입니다.

1. 정수 목록이 주어지면, 정렬된 후 중간 위치에 있는 값(벡터에서)과 가장 자주 나타나는 값(해시 맵이 도움이 됩니다)을 반환하는 메디언과 모드를 사용하여 벡터를 반환합니다.
1. 문자열을 피그 라틴으로 변환합니다. 각 단어의 첫 번째 자음은 단어의 끝으로 이동하고 *ay*가 추가되므로 *first*는 *irst-fay*가 됩니다. 모음으로 시작하는 단어에는 *hay*가 끝에 추가됩니다 (*apple*은 *apple-hay*가 됩니다). UTF-8 인코딩의 세부 사항을 기억하세요!
1. 해시 맵과 벡터를 사용하여 사용자가 회사의 부서에 직원 이름을 추가할 수 있는 텍스트 인터페이스를 만듭니다. 예를 들어, \u201cSally를 엔지니어링에 추가\u201d 또는 \u201cAmir를 영업에 추가\u201d와 같습니다. 그런 다음 사용자가 부서별 또는 부서별로 모든 사람의 목록을 알파벳 순서로 검색할 수 있도록 합니다.

표준 라이브러리 API 문서는 벡터, 문자열 및 해시 맵이 가진 유용한 메서드에 대한 설명을 제공합니다. 이러한 연습 문제에 도움이 될 것입니다!

우리는 더 복잡한 프로그램으로 진행되고 있으며, 작업이 실패할 수 있으므로 오류 처리에 대해 논의하는 것이 좋습니다. 다음에 그에 대해 논의하겠습니다!

[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[access]: #accessing-values-in-a-hash-map
[traits]: ch10-02-traits.html
