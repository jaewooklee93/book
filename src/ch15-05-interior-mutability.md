## `RefCell<T>`와 내부 가변성 패턴

*내부 가변성*은 Rust에서 불변 참조가 있는 데이터에도 변조할 수 있는 디자인 패턴입니다. 일반적으로 이 작업은 대출 규칙에 의해 금지됩니다. 이 패턴은 데이터 구조 내부에서 `unsafe` 코드를 사용하여 Rust의 일반적인 변조 및 대출 규칙을 굽히는 방법을 사용하여 변조할 수 있습니다. `unsafe` 코드는 우리가 컴파일러가 대신 확인해 줄 대신 규칙을 수동으로 확인하고 있음을 나타냅니다. 우리는 19장에서 `unsafe` 코드에 대해 더 자세히 논의할 것입니다.

우리는 대출 규칙이 컴파일러가 보장할 수 없지만, 실행 시에 따르는 것을 보장할 수 있는 경우에만 내부 가변성 패턴을 사용하는 유형을 사용할 수 있습니다. 관련된 `unsafe` 코드는 안전한 API로 래핑되며, 외부 유형은 여전히 불변입니다.

내부 가변성 패턴을 따르는 `RefCell<T>` 유형을 살펴보면서 이 개념을 탐색해 보겠습니다.

### `RefCell<T>`를 사용하여 실행 시 대출 규칙을 강제

`Rc<T>`와 달리 `RefCell<T>` 유형은 데이터를 가진 단일 소유권을 나타냅니다. 그러므로 `RefCell<T>`가 `Box<T>`와 같은 유형과 다른 점은 무엇일까요? 4장에서 배운 대출 규칙을 기억하세요:

* 어떤 시점에서든 하나의 가변 참조 또는 여러 개의 불변 참조 중 하나만 있을 수 있습니다.
* 참조는 항상 유효해야 합니다.

참조와 `Box<T>`의 경우, 대출 규칙의 불변성은 컴파일 시간에 강제됩니다. `RefCell<T>`의 경우, 이러한 불변성은 *실행 시간*에 강제됩니다. 참조의 경우 대출 규칙을 위반하면 컴파일 오류가 발생합니다. `RefCell<T>`의 경우 대출 규칙을 위반하면 프로그램이 충돌하여 종료됩니다.

컴파일 시간에 대출 규칙을 검사하는 장점은 오류가 개발 프로세스에서 더 빨리 감지되고, 모든 분석이 미리 완료되기 때문에 실행 시간 성능에 영향이 없기 때문입니다. 이러한 이유로 대부분의 경우 컴파일 시간에 대출 규칙을 검사하는 것이 가장 좋은 선택입니다.

실행 시간에 대출 규칙을 검사하는 장점은 일부 메모리 안전한 시나리오가 허용될 수 있는 것입니다. 정적 분석은 Rust 컴파일러와 같이 코드를 분석하는 것입니다. 일부 코드의 특성은 분석을 통해 감지할 수 없습니다. 가장 유명한 예는 컴파일러가 분석할 수 없는 Halting 문제입니다. 이는 이 책의 범위를 벗어나지만 연구할 가치 있는 주제입니다.

컴파일러가 코드가 소유권 규칙을 준수하는지 확신할 수 없으면, 컴파일러는 `RefCell<T>` 유형과 같이 컴파일 시간에 검사할 수 없는 코드를 거부할 수 있습니다. `RefCell<T>` 유형은 코드가 대출 규칙을 따르는 데 확신할 때, 컴파일러가 이해하고 보장할 수 없는 경우에 유용합니다.

`RefCell<T>` 유형은 단일 스레드 환경에서만 사용되며, 다중 스레드 환경에서 사용하려고 하면 컴파일 시간 오류가 발생합니다. 다중 스레드 프로그램에서 `RefCell<T>` 유형의 기능을 얻는 방법은 16장에서 논의할 것입니다.

`Box<T>`, `Rc<T>` 또는 `RefCell<T>`를 선택하는 이유를 요약하면 다음과 같습니다.

* `Rc<T>`는 동일한 데이터의 여러 소유자를 허용합니다. `Box<T>`와 `RefCell<T>`는 단일 소유자를 가지고 있습니다.
* `Box<T>`는 컴파일 시간에 검사되는 불변 또는 가변 대출을 허용합니다. `Rc<T>`는 컴파일 시간에 검사되는 불변 대출만 허용합니다. `RefCell<T>`는 실행 시간에 검사되는 불변 또는 가변 대출을 허용합니다.
* `RefCell<T>`가 실행 시간에 검사되는 가변 대출을 허용하기 때문에 `RefCell<T>` 내부의 값을 불변 `RefCell<T>`인 경우에도 변조할 수 있습니다.

불변 값 내부의 값을 변조하는 것은 *내부 가변성* 패턴입니다. 내부 가변성이 유용한 상황을 살펴보고 어떻게 가능한지 살펴보겠습니다.

### 내부 가변성: 불변 값에 대한 가변 대출

대출 규칙의 결과로 불변 값이 있으면 불변 참조로 대출할 수 없습니다. 예를 들어 다음 코드는 컴파일되지 않습니다.
```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}
```

이 코드를 컴파일하려고 하면 다음과 같은 오류가 발생합니다.

```console
{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}
```

그러나 값이 자신의 메서드에서 변형되지만 다른 코드에는 불변으로 보이는 경우에는 유용한 상황이 있습니다. 값의 메서드 외부의 코드는 값을 변형할 수 없습니다. `RefCell<T>`를 사용하면 내부 변수의 변경 가능성을 얻을 수 있는 방법 중 하나이지만, `RefCell<T>`는 대출 규칙을 완전히 무시하지 않습니다. 컴파일러의 대출 검사기는 이러한 내부 변수의 변경 가능성을 허용하며, 대출 규칙은 런타임에 검사됩니다. 규칙을 위반하면 `panic!`가 발생하여 컴파일러 오류가 발생하지 않습니다.

실제 예제를 통해 `RefCell<T>`를 사용하여 불변 값을 변형하고 그 이유가 왜 유용한지 살펴보겠습니다.

#### 내부 변수의 변경 가능성의 사용 사례: 가짜 객체

때때로 프로그래머는 테스트 중 다른 유형을 대체하여 특정 동작을 관찰하고 올바르게 구현되었는지 확인하기 위해 유형을 사용합니다. 이 임시 대체 유형을 *테스트 더블*이라고 합니다. 영화에서의 *스턴트 더블*과 같은 개념으로 생각할 수 있습니다. 스턴트 더블은 특정 어려운 장면을 대신하여 배우를 대체합니다. 테스트 더블은 테스트를 수행할 때 다른 유형을 대체합니다. *가짜 객체*는 특정 테스트 더블 유형으로, 테스트 중에 발생하는 사건을 기록하여 올바른 작업이 수행되었는지 확인할 수 있도록 합니다.

Rust은 다른 언어에서 객체를 가지는 방식과 동일한 객체를 가지고 있지 않으며, Rust은 기본 라이브러리에 가짜 객체 기능이 포함되어 있지 않습니다. 그러나 `RefCell<T>`를 사용하여 가짜 객체를 구현할 수 있습니다.

우리가 테스트할 시나리오는 다음과 같습니다. 특정 값을 최대 값에 대해 추적하고 현재 값이 최대 값에 얼마나 가까운지에 따라 메시지를 보냅니다. 이 라이브러리는 예를 들어 사용자가 API 호출을 할 수 있는 권한을 가진 횟수를 추적하는 데 사용될 수 있습니다.

라이브러리는 현재 값이 최대 값에 얼마나 가까운지 추적하고 각 단계에서 메시지가 어떻게 보내야 하는지에 대한 기능만 제공합니다. 라이브러리를 사용하는 응용 프로그램은 메시지를 보내는 메커니즘을 제공해야 합니다. 응용 프로그램은 메시지를 응용 프로그램에 넣거나 이메일을 보내거나 문자 메시지를 보내거나 다른 작업을 수행할 수 있습니다. 라이브러리는 그 세부 사항을 알 필요가 없습니다. `Messenger`라는 추상화된 인터페이스를 구현하는 것만으로도 충분합니다.

<span class=\"filename\">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-20/src/lib.rs}}
```

<span class=\"caption\">Listing 15-20: 특정 값이 최대 값에 얼마나 가까운지 추적하고 특정 수준에 도달하면 경고 메시지를 보내는 라이브러리</span>

이 코드의 중요한 부분은 `Messenger` 트레이트가 `send` 메서드를 하나 가지고 있으며, 이 메서드는 `self`의 무효 참조와 메시지 텍스트를 받습니다. 이 트레이트는 가짜 객체가 실제 객체와 동일한 방식으로 사용될 수 있도록 하는 인터페이스입니다. 또 다른 중요한 부분은 `set_value` 메서드의 동작을 테스트하고 싶습니다. `value` 매개변수에 다양한 값을 전달할 수 있지만, `set_value`는 우리가 주장을 할 수 있는 값을 반환하지 않습니다. `LimitTracker`의 `set_value` 메서드를 호출했을 때, 가짜 객체를 사용하여 `Messenger` 트레이트를 구현하고 `max` 값을 설정하면 메시지가 올바르게 전달되는지 확인하고 싶습니다.

`send` 메서드를 호출할 때 이메일이나 문자 메시지를 보내는 대신 메시지를 기록하는 가짜 객체가 필요합니다. 새로운 가짜 객체 인스턴스를 만들고 `Messenger` 트레이트를 구현한 가짜 객체를 사용하여 `LimitTracker`를 만들고 `set_value` 메서드를 호출한 후, 가짜 객체가 기록한 메시지를 확인할 수 있습니다.
모의 객체에는 우리가 기대하는 메시지가 있습니다. 15-21번 목록은 그렇게 하는 모의 객체를 구현하려는 시도를 보여주지만, 보로 체커는 허용하지 않습니다.

<span class=\"filename\">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-21/src/lib.rs:here}}
```

<span class=\"caption\">15-21번 목록: 보로 체커가 허용하지 않는 `MockMessenger` 구현 시도</span>

이 테스트 코드는 `sent_messages` 필드가 메시지를 보관하기 위해 `Vec<String>` 값을 가진 `MockMessenger` 구조체를 정의합니다. 또한 `new` 연관 함수를 정의하여 메시지 목록이 비어 있는 새로운 `MockMessenger` 값을 만들기 쉽게 합니다. 그런 다음 `MockMessenger` 에 대해 `Messenger` 트레이트를 구현하여 `MockMessenger` 를 `LimitTracker` 에 줄 수 있습니다. `send` 메서드의 정의에서 전달된 메시지를 매개변수로 받아 `MockMessenger` 의 `sent_messages` 목록에 저장합니다.

테스트에서는 `LimitTracker` 에 `max` 값이 100이고 `value` 를 100보다 75% 이상으로 설정하도록 지시했을 때 어떤 일이 일어나는지 테스트합니다. 먼저 빈 메시지 목록으로 시작하는 새로운 `MockMessenger` 를 만듭니다. 다음으로 새로운 `LimitTracker` 를 만들고 새로운 `MockMessenger` 에 대한 참조와 `max` 값이 100인 것을 제공합니다. `LimitTracker` 에 `set_value` 메서드를 100의 80으로 호출합니다. 그런 다음 `MockMessenger` 가 추적하는 메시지 목록에 하나의 메시지가 있는지 확인합니다.

그러나 이 테스트에는 다음과 같은 문제가 있습니다.

```console
{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}
```

`send` 메서드가 `self` 에 대한 불변 참조를 받기 때문에 `MockMessenger` 를 수정하여 메시지를 추적할 수 없습니다. 또한 오류 메시지에서 제시된 제안인 `&mut self` 를 사용하는 것도 좋지 않습니다. 그렇게 하면 `send` 의 서명이 `Messenger` 트레이트 정의의 서명과 일치하지 않기 때문입니다. (서명이 일치하지 않는다는 오류 메시지를 확인해 보세요.)

이것은 내부 가변성이 도움이 될 수 있는 상황입니다! `RefCell<T>` 안에 `sent_messages` 를 저장하고 `send` 메서드가 보관된 메시지를 저장하도록 수정할 수 있습니다. 15-22번 목록은 그렇게 하는 방법을 보여줍니다.

<span class=\"filename\">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-22/src/lib.rs:here}}
```

<span class=\"caption\">15-22번 목록: 외부 값이 불변으로 간주되면서 내부 값을 수정하는 `RefCell<T>` 사용</span>

`sent_messages` 필드는 이제 `Vec<String>` 대신 `RefCell<Vec<String>>` 유형입니다. `new` 함수에서 빈 벡터 주위에 새로운 `RefCell<Vec<String>>` 인스턴스를 만듭니다.

`send` 메서드의 구현에서는 첫 번째 매개변수가 여전히 트레이트 정의와 일치하는 `self` 에 대한 불변 참조입니다. `self.sent_messages` 에 있는 `RefCell<Vec<String>>` 에 `borrow_mut` 를 호출하여 `RefCell<Vec<String>>` 안의 값에 대한 가변 참조를 가져옵니다. 그런 다음 벡터에 대한 가변 참조를 사용하여 테스트 중에 보낸 메시지를 추적할 수 있습니다.

마지막으로 변경해야 할 부분은 주장입니다. 내부 벡터에 있는 항목 수를 확인하려면 `RefCell<Vec<String>>` 에 `borrow` 를 호출하여 벡터에 대한 불변 참조를 가져옵니다.

이제 `RefCell<T>` 를 사용하는 방법을 보았으므로 작동 방식을 자세히 살펴보겠습니다.

#### `RefCell<T>` 로 실행 시간에 대한 참조 추적

불변 참조와 가변 참조를 만들 때는 각각 `&` 와 `&mut` 문법을 사용합니다. `RefCell<T>`의 경우, 안전한 API에 속하는 `borrow` 와 `borrow_mut` 메서드를 사용합니다. `borrow` 메서드는 스마트 포인터 유형 `Ref<T>`를 반환하고, `borrow_mut` 는 스마트 포인터 유형 `RefMut<T>`를 반환합니다. 두 유형 모두 `Deref`를 구현하기 때문에 정상적인 참조처럼 취급할 수 있습니다.

`RefCell<T>`는 현재 활성화된 `Ref<T>` 와 `RefMut<T>` 스마트 포인터의 개수를 추적합니다. `borrow`를 호출할 때마다 `RefCell<T>`는 활성화된 불변 참조 개수를 1 증가시킵니다. `Ref<T>` 값이 범위를 벗어날 때마다 불변 참조 개수는 1 감소합니다. 컴파일 시간의 대여 규칙과 마찬가지로 `RefCell<T>`는 동시에 여러 개의 불변 참조 또는 하나의 가변 참조를 허용합니다.

이러한 규칙을 위반하려고 하면, 참조와 같이 컴파일러 오류를 받는 대신, `RefCell<T>`의 구현은 실행 시간에 panic합니다. 15-23번 목록은 15-22번 목록의 `send` 함수 구현의 수정을 보여줍니다. `borrow_mut`를 사용하여 두 개의 가변 참조를 동시에 활성화하려고 의도적으로 시도하고 있습니다. `RefCell<T>`가 동시에 두 개의 가변 참조를 허용하지 않는다는 것을 보여줍니다.

<span class=\"filename\">Filename: src/lib.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-23/src/lib.rs:here}}
```

<span class=\"caption\">Listing 15-23: 동일한 범위에서 두 개의 가변 참조를 생성하여 `RefCell<T>`가 panic한다는 것을 보여줍니다</span>

`RefMut<T>` 스마트 포인터로 반환된 `borrow_mut`를 `one_borrow` 변수에 저장합니다. 그런 다음 동일한 방식으로 같은 범위에서 또 다른 가변 참조를 생성합니다. 이는 동일한 범위에서 두 개의 가변 참조를 만듭니다. 이는 허용되지 않습니다. 라이브러리의 테스트를 실행하면 15-23번 목록의 코드는 오류 없이 컴파일되지만 테스트는 실패합니다.

```console
{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}
```

`BorrowMutError` 메시지와 함께 코드가 panic했다는 것을 알 수 있습니다. 이것이 `RefCell<T>`가 실행 시간에 대여 규칙 위반을 처리하는 방식입니다.

실행 시간에 대여 오류를 검출하는 대신 컴파일 시간에 검출하는 것을 선택하면, 코드에서 실수를 늦게 발견할 수 있습니다. 즉, 코드가 배포되기까지 또는 생산에 배포될 때까지입니다. 또한, 컴파일 시간에 대여를 추적하는 대신 실행 시간에 추적하기 때문에 코드가 작은 실행 시간 성능 손실을 겪게 됩니다. 그러나 `RefCell<T>`를 사용하면 불변 값만 허용되는 맥락에서 사용하는 동안 본인을 수정하여 본인이 본 적은 메시지를 추적하는 가짜 객체를 작성할 수 있습니다. `RefCell<T>`는 정규 참조가 제공하는 것보다 더 많은 기능을 얻기 위해 그러한 단점을 감수하여 사용할 수 있습니다.

### `Rc<T>`와 `RefCell<T>`를 결합하여 여러 소유자가 가변 데이터를 가질 수 있도록 함

`RefCell<T>`는 `Rc<T>`와 함께 사용하는 데 자주 사용됩니다. `Rc<T>`는 여러 소유자가 데이터를 소유할 수 있도록 허용하지만, 해당 데이터에 불변 접근 권한만 제공합니다. `RefCell<T>`를 포함하는 `Rc<T>`를 가지면 여러 소유자를 가질 수 있고, 동시에 수정할 수도 있습니다!

예를 들어, 15-18번 목록에서 `Rc<T>`를 사용하여 다른 리스트가 다른 리스트의 소유권을 공유하는 연결 리스트 예제를 기억하세요. `Rc<T>`가 불변 값만 저장하기 때문에, 리스트를 생성한 후에는 리스트에 저장된 값을 변경할 수 없습니다. `RefCell<T>`를 사용하여 `Cons` 정의에 추가하면 모든 리스트에 저장된 값을 변경할 수 있습니다.

<span class=\"filename\">Filename: src/main.rs</span>

```rust
```

<span class=\"caption\">Listing 15-24: `Rc<RefCell<i32>>`를 사용하여 수정 가능한
`List` 생성</span>

`Rc<RefCell<i32>>` 인스턴스를 생성하고 `value` 변수에 저장하여 나중에 직접 액세스할 수 있도록 합니다. 다음으로 `Cons` 변형을 가진 `List` 를 `a` 에 생성하고 `value` 를 포함합니다. `value` 를 복사해야 `a` 와 `value` 가 모두 내부 `5` 값의 소유권을 가지고 있고, 소유권이 `value` 에서 `a` 로 전달되거나 `a` 가 `value` 에서 대출하지 않도록 합니다.

`Rc<T>` 로 `List` `a` 를 감싸면 `b` 와 `c` 와 같은 다른 리스트가 `a` 에 참조할 수 있게 됩니다. 이는 Listing 15-18 에서와 같습니다.

`a`, `b`, `c` 리스트를 생성한 후, `value` 에 있는 값에 10을 더하고 싶습니다. `borrow_mut` 를 `value` 에 호출하여 이를 수행합니다. `borrow_mut` 메서드는 제5장에서 논의한 자동 해제 기능(Chapter 5 참조: [“Where’s the `->` Operator?”][wheres-the---operator]<!-- ignore -->)을 사용하여 `Rc<T>` 를 내부 `RefCell<T>` 값으로 해제합니다. `borrow_mut` 메서드는 `RefMut<T>` 스마트 포인터를 반환하고, 이를 해제 연산자를 사용하여 내부 값을 변경합니다.

`a`, `b`, `c` 를 출력하면, 모두 수정된 값인 15를 가지고 있음을 확인할 수 있습니다. 5가 아닌 것입니다.

```console
{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}
```

이 기술은 매우 멋지습니다! `RefCell<T>` 를 사용하면 외부에서 불변인 `List` 값을 얻을 수 있습니다. 그러나 `RefCell<T>` 의 메서드를 사용하여 내부의 가변성에 액세스하여 필요할 때 데이터를 수정할 수 있습니다. 대출 규칙의 런타임 검사는 데이터 레이스로부터 우리를 보호하고, 데이터 구조에서 이러한 유연성을 얻기 위해 속도를 조금 희생하는 것은 때때로 가치가 있습니다. `RefCell<T>` 는 다중 스레드 코드에 대해 작동하지 않습니다. `Mutex<T>` 는 `RefCell<T>` 의 스레드 안전한 버전이며, Chapter 16 에서 `Mutex<T>` 에 대해 논의할 것입니다.

[wheres-the---operator]: ch05-03-method-syntax.html#wheres-the---operator
